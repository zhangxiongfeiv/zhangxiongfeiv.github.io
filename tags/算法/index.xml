<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 飞熊&#39;s Blogs&#39;</title>
    <link>https://zhangxiongfeiv.github.io/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on 飞熊&#39;s Blogs&#39;</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 12 May 2020 22:31:36 +0800</lastBuildDate>
    
	<atom:link href="https://zhangxiongfeiv.github.io/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode面试题集锦</title>
      <link>https://zhangxiongfeiv.github.io/post/leetcode%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/leetcode%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/</guid>
      <description>leetcode上面试题目集合 面试题 01.01. 判定字符是否唯一 实现一个算法，确定一个字符串 s 的所有字符是否全都不同。 示例 1： 输入: s = &amp;ldquo;leetcode&amp;rdquo; 输出: false 示例</description>
    </item>
    
    <item>
      <title>买卖股票的最佳时机</title>
      <link>https://zhangxiongfeiv.github.io/post/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Sat, 09 May 2020 21:40:52 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</guid>
      <description>买卖股票的最佳时机 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个</description>
    </item>
    
    <item>
      <title>152. 乘积最大子数组</title>
      <link>https://zhangxiongfeiv.github.io/post/152.-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 09 May 2020 21:40:02 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/152.-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>152. 乘积最大子数组 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。 示例 1: 输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有</description>
    </item>
    
    <item>
      <title>最大子序和DP</title>
      <link>https://zhangxiongfeiv.github.io/post/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8Cdp/</link>
      <pubDate>Tue, 28 Apr 2020 20:56:35 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8Cdp/</guid>
      <description>53. 最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数</description>
    </item>
    
    <item>
      <title>最长公共子序列DP</title>
      <link>https://zhangxiongfeiv.github.io/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97dp/</link>
      <pubDate>Tue, 28 Apr 2020 18:10:13 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97dp/</guid>
      <description>1143. 最长公共子序列 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符</description>
    </item>
    
    <item>
      <title>三角形最小路径和DP</title>
      <link>https://zhangxiongfeiv.github.io/post/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8Cdp/</link>
      <pubDate>Tue, 28 Apr 2020 14:27:19 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8Cdp/</guid>
      <description>三角形最小路径和 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小</description>
    </item>
    
    <item>
      <title>最长上升子序列DP</title>
      <link>https://zhangxiongfeiv.github.io/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97dp/</link>
      <pubDate>Tue, 28 Apr 2020 11:25:21 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97dp/</guid>
      <description>300. 最长上升子序列 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，</description>
    </item>
    
    <item>
      <title>213.打家劫舍DPII</title>
      <link>https://zhangxiongfeiv.github.io/post/213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Ddpii/</link>
      <pubDate>Mon, 27 Apr 2020 22:08:29 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Ddpii/</guid>
      <description>213. 打家劫舍 II 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋</description>
    </item>
    
    <item>
      <title>198.打家劫舍DP</title>
      <link>https://zhangxiongfeiv.github.io/post/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Ddp/</link>
      <pubDate>Mon, 27 Apr 2020 21:06:09 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Ddp/</guid>
      <description>198. 打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如</description>
    </item>
    
    <item>
      <title>零钱找零DP</title>
      <link>https://zhangxiongfeiv.github.io/post/%E9%9B%B6%E9%92%B1%E6%89%BE%E9%9B%B6dp/</link>
      <pubDate>Mon, 27 Apr 2020 17:40:44 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E9%9B%B6%E9%92%B1%E6%89%BE%E9%9B%B6dp/</guid>
      <description>零钱兑换 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总</description>
    </item>
    
    <item>
      <title>一文了解动态规划(Dynamic Programming)</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 27 Apr 2020 10:20:11 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</guid>
      <description>动态规划(Dynamic Programming) 简称 DP , 是求解最优化问题的一种常用策略。 来自维基百科的解释： Dynamic Programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once,and</description>
    </item>
    
    <item>
      <title>冒泡排序(BubbleSort)</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>冒泡排序(BubbleSort) 执行流程 依次比较两个相邻元素如果前者比后者大，交换两者 一轮比较完毕，则最后一个元素为最大者 再进行第二轮比较，</description>
    </item>
    
    <item>
      <title>堆排序(Heap Sort)</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%A0%86%E6%8E%92%E5%BA%8Fheap-sort/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%A0%86%E6%8E%92%E5%BA%8Fheap-sort/</guid>
      <description>堆排序(Heap Sort) 堆排序可以认为是选择排序的一种优化。 选择排序每一轮都在选择最大值 而选择最大值，最优的数据结构是堆 故用堆排序 优化 选择排序 执行</description>
    </item>
    
    <item>
      <title>快速排序(Quick Sort)</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%BF%AB%E6%8E%92/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%BF%AB%E6%8E%92/</guid>
      <description>快速排序(Quick Sort) 快速排序(Quick Sort) 1960年由 查尔斯.安东尼.理查德.霍尔提出。 执行流程 随机选择一个为数列的轴点元素 遍历数组，把小</description>
    </item>
    
    <item>
      <title>插入排序(Insertion Sort)</title>
      <link>https://zhangxiongfeiv.github.io/post/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Finsertion-sort/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Finsertion-sort/</guid>
      <description>插入排序(Insertion Sort) 执行流程 从第一位开始, 依次与之前元素比较 当比之前元素小时, 交换 挨个交换直到 末尾元素 最差时间复杂度 : O(N ^ 2) 平均时</description>
    </item>
    
    <item>
      <title>选择排序(Selection Sort)</title>
      <link>https://zhangxiongfeiv.github.io/post/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
      <description>选择排序(Selection Sort) 执行流程 找出数组中最大的那个元素，和数组末尾元素进行叫魂 执行完一轮后，数组末尾的元素就是最大元素 依次找出剩余元</description>
    </item>
    
    <item>
      <title>数据结构学习 --&gt; 算法评判标准</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Wed, 08 Apr 2020 17:33:35 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description>首先看一到leetcode题目:斐波那契数列。 509. 斐波那契数 斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每</description>
    </item>
    
    <item>
      <title>字符串常用算法 --&gt; 滑动窗口</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link>
      <pubDate>Mon, 06 Apr 2020 21:16:57 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid>
      <description>字符串算法之滑动窗口 题目 3. 无重复字符的最长子串 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: &amp;ldquo;abcabcbb&amp;rdquo; 输出: 3 解释: 因为无</description>
    </item>
    
    <item>
      <title>字符串常用算法 --&gt; 双指针</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Fri, 05 Apr 2019 20:52:54 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
      <description>151. 翻转字符串里的单词 题目 给定一个字符串，逐个反转字符串中的每个单词 示例 1： 输入: &amp;quot;the sky is blue&amp;quot; 输出: &amp;quot;blue is sky the&amp;quot; 说明： 无空格字符构成一个单词。 输入字符</description>
    </item>
    
  </channel>
</rss>