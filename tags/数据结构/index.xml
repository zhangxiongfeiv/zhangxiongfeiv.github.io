<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构 on API调用工程师的进阶</title>
    <link>https://zhxiongfei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 数据结构 on API调用工程师的进阶</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 28 Jun 2020 09:57:36 +0800</lastBuildDate>
    
	<atom:link href="https://zhxiongfei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>剑指.Offer.31.栈的压入</title>
      <link>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87.offer.31.%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5.%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sun, 28 Jun 2020 09:57:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87.offer.31.%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5.%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</guid>
      <description>剑指 Offer 31. 栈的压入、弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。</description>
    </item>
    
    <item>
      <title>简单了解并查集</title>
      <link>https://zhxiongfei.github.io/post/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Mon, 08 Jun 2020 13:55:31 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>需求分析 假设有 N 个村庄, 有些村庄之间有连接的路，有些村庄之间没有连接的路 设计一个数据结构，能够快速执行两个操作 查询两个村庄之间是否有连接的路</description>
    </item>
    
    <item>
      <title>278.寻找重复数</title>
      <link>https://zhxiongfei.github.io/post/278.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</link>
      <pubDate>Fri, 05 Jun 2020 12:55:09 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/278.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</guid>
      <description>287. 寻找重复数 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，</description>
    </item>
    
    <item>
      <title>剑指offer.52.两个链表的第一个公共节点</title>
      <link>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.52.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 02 Jun 2020 21:54:04 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.52.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description>面试题52. 两个链表的第一个公共节点 输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：interse</description>
    </item>
    
    <item>
      <title>剑指offer.68.二叉树的最近公共祖先</title>
      <link>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.68.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Tue, 02 Jun 2020 21:51:04 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.68.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>面试题68 - I. 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树</description>
    </item>
    
    <item>
      <title>团灭丑数问题</title>
      <link>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E4%B8%91%E6%95%B0%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 30 May 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E4%B8%91%E6%95%B0%E9%97%AE%E9%A2%98/</guid>
      <description>什么是丑数？ 先看一下百度百科的解释: 说法一（ugly number）：把只包含质因子2，3和5的数称作丑数（Ugly Number）。例如6、8</description>
    </item>
    
    <item>
      <title>二叉堆</title>
      <link>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E5%A0%86/</link>
      <pubDate>Fri, 29 May 2020 17:27:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E5%A0%86/</guid>
      <description>二叉堆 概念 堆是一个可以被看作近似完全二叉树的数组。树上的每一个节点对应数组的一个元素。出了最底层外，该树是完全充满的，而且是从左到右填充哦。</description>
    </item>
    
    <item>
      <title>01.08零矩阵</title>
      <link>https://zhxiongfei.github.io/post/01.08%E9%9B%B6%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Thu, 28 May 2020 22:55:05 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.08%E9%9B%B6%E7%9F%A9%E9%98%B5/</guid>
      <description>面试题 01.08. 零矩阵 编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。 示例 1： 输入： [ [1,1,1], [1,0,1], [1,1,1] ] 输出： [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2： 输入： [ [0,1,2,0], [3,4,5,2],</description>
    </item>
    
    <item>
      <title>01.06字符串压缩</title>
      <link>https://zhxiongfei.github.io/post/01.06%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</link>
      <pubDate>Thu, 28 May 2020 22:37:48 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.06%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</guid>
      <description>面试题 01.06. 字符串压缩 字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b</description>
    </item>
    
    <item>
      <title>01.05一次编辑</title>
      <link>https://zhxiongfei.github.io/post/01.05%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/</link>
      <pubDate>Thu, 28 May 2020 22:32:11 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.05%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/</guid>
      <description>面试题 01.05. 一次编辑 字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零</description>
    </item>
    
    <item>
      <title>01.04.回文排列</title>
      <link>https://zhxiongfei.github.io/post/01.04%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97/</link>
      <pubDate>Thu, 28 May 2020 22:27:06 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.04%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97/</guid>
      <description>面试题 01.04. 回文排列 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。 回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排</description>
    </item>
    
    <item>
      <title>01.03URL化</title>
      <link>https://zhxiongfei.github.io/post/01.03url%E5%8C%96/</link>
      <pubDate>Thu, 28 May 2020 22:22:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.03url%E5%8C%96/</guid>
      <description>面试题 01.03. URL化 URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”</description>
    </item>
    
    <item>
      <title>01.02判断是否互为字符重排</title>
      <link>https://zhxiongfei.github.io/post/01.02%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/</link>
      <pubDate>Thu, 28 May 2020 22:18:56 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.02%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/</guid>
      <description>面试题 01.02. 判定是否互为字符重排 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。 示例 1： 输入:</description>
    </item>
    
    <item>
      <title>01.01判断字符是否唯一</title>
      <link>https://zhxiongfei.github.io/post/01.01%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</link>
      <pubDate>Thu, 28 May 2020 22:15:10 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.01%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</guid>
      <description>面试题 01.01. 判定字符是否唯一 实现一个算法，确定一个字符串 s 的所有字符是否全都不同。 示例 1： 输入: s = &amp;ldquo;leetcode&amp;rdquo; 输出: false 示例 2： 输入: s = &amp;ldquo;abc&amp;rdquo; 输出: true 限制：</description>
    </item>
    
    <item>
      <title>LeetCode刷题回顾与总结</title>
      <link>https://zhxiongfei.github.io/post/leetcode%E5%88%B7%E9%A2%98%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 28 May 2020 10:09:44 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/leetcode%E5%88%B7%E9%A2%98%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/</guid>
      <description>LeetCode刷题回顾与总结 2020.5.27记 截止 5.27日，leetcode总刷题数到达200，写一篇文章以回顾，总结。 起因 非计算机专</description>
    </item>
    
    <item>
      <title>86.分隔链表</title>
      <link>https://zhxiongfei.github.io/post/86.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 26 May 2020 17:09:30 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/86.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</guid>
      <description>86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对</description>
    </item>
    
    <item>
      <title>01.09字符串轮转</title>
      <link>https://zhxiongfei.github.io/post/01.09%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.09%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC/</guid>
      <description>面试题 01.09. 字符串轮转 字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottle</description>
    </item>
    
    <item>
      <title>02.01移除重复节点</title>
      <link>https://zhxiongfei.github.io/post/02.01%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.01%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</guid>
      <description>面试题 02.01. 移除重复节点 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。 示例1: 输入：[1, 2, 3, 3, 2, 1] 输出：[1, 2, 3] 示例2: 输入：</description>
    </item>
    
    <item>
      <title>02.02链表的倒数第二个节点</title>
      <link>https://zhxiongfei.github.io/post/02.02%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.02%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>面试题 02.02. 返回倒数第 k 个节点 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 注意：本题相对原题稍作改动 示例： 输入： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 和 k = 2 输出：</description>
    </item>
    
    <item>
      <title>02.03删除中间节点</title>
      <link>https://zhxiongfei.github.io/post/02.03%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.03%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</guid>
      <description>面试题 02.03. 删除中间节点 实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。 示例： 输入</description>
    </item>
    
    <item>
      <title>02.04分割链表</title>
      <link>https://zhxiongfei.github.io/post/02.04%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.04%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</guid>
      <description>面试题 02.04. 分割链表 编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(</description>
    </item>
    
    <item>
      <title>02.05链表求和</title>
      <link>https://zhxiongfei.github.io/post/02.05%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.05%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/</guid>
      <description>面试题 02.05. 链表求和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 给定两个用链表表示的整数，每个节点包含一个数位。 这些数位是反向存放的，也就是个位</description>
    </item>
    
    <item>
      <title>02.08环路检测</title>
      <link>https://zhxiongfei.github.io/post/02.08%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.08%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/</guid>
      <description>面试题 02.08. 环路检测 给定一个有环链表，实现一个算法返回环路的开头节点。 有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则</description>
    </item>
    
    <item>
      <title>03.02栈的最小值</title>
      <link>https://zhxiongfei.github.io/post/03.02%E6%A0%88%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/03.02%E6%A0%88%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</guid>
      <description>面试题 03.02. 栈的最小值 请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop</description>
    </item>
    
    <item>
      <title>03.04化栈为队</title>
      <link>https://zhxiongfei.github.io/post/03.04%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/03.04%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F/</guid>
      <description>面试题 03.04. 化栈为队 实现一个MyQueue类，该类用两个栈来实现一个队列。 示例： MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false 说明： 你只能使用标准</description>
    </item>
    
    <item>
      <title>04.02最小高度树</title>
      <link>https://zhxiongfei.github.io/post/04.02%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/04.02%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</guid>
      <description>面试题 04.02. 最小高度树 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能</description>
    </item>
    
    <item>
      <title>04.03特定深度节点链表</title>
      <link>https://zhxiongfei.github.io/post/04.03%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/04.03%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/</guid>
      <description>面试题 04.03. 特定深度节点链表 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回</description>
    </item>
    
    <item>
      <title>04.05合法二叉搜索树</title>
      <link>https://zhxiongfei.github.io/post/04.05%E5%90%88%E6%B3%95%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/04.05%E5%90%88%E6%B3%95%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>面试题 04.05. 合法二叉搜索树 实现一个函数，检查一棵二叉树是否为二叉搜索树。 示例 1: 输入: 2 / 1 3 输出: true 示例 2: 输入: 5 / 1 4 / 3 6 输出: false 解释: 输入</description>
    </item>
    
    <item>
      <title>04.06后继者</title>
      <link>https://zhxiongfei.github.io/post/04.06%E5%90%8E%E7%BB%A7%E8%80%85/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/04.06%E5%90%8E%E7%BB%A7%E8%80%85/</guid>
      <description>面试题 04.06. 后继者 设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。 如果指定节点没有对应的“下一个”节点，则返回null。</description>
    </item>
    
    <item>
      <title>04.08首个公共祖先</title>
      <link>https://zhxiongfei.github.io/post/04.08%E9%A6%96%E4%B8%AA%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/04.08%E9%A6%96%E4%B8%AA%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>面试题 04.08. 首个共同祖先 设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉</description>
    </item>
    
    <item>
      <title>04.10检查子树</title>
      <link>https://zhxiongfei.github.io/post/04.10%E6%A3%80%E6%9F%A5%E5%AD%90%E6%A0%91/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/04.10%E6%A3%80%E6%9F%A5%E5%AD%90%E6%A0%91/</guid>
      <description>面试题 04.10. 检查子树 检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。 如果 T1 有这么一</description>
    </item>
    
    <item>
      <title>110.平衡二叉树</title>
      <link>https://zhxiongfei.github.io/post/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值</description>
    </item>
    
    <item>
      <title>AVL树</title>
      <link>https://zhxiongfei.github.io/post/avl%E6%A0%91/</link>
      <pubDate>Mon, 11 May 2020 21:04:44 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/avl%E6%A0%91/</guid>
      <description>AVL树 平衡因子(Balance Factor): 某节点左右子树的高度差 AVL树的特点 每个节点的平衡因子只可能是1, 0, -1(绝对值 &amp;lt;= 1, 如果超过1，称之为 &amp;l</description>
    </item>
    
    <item>
      <title>平衡二叉搜索树</title>
      <link>https://zhxiongfei.github.io/post/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Mon, 11 May 2020 21:03:47 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>平衡二叉搜索树 (BBST) 二叉搜索树(BST)的缺陷？ 二叉搜索树，在某种情况下会导致极度的不平衡，导致时间复杂度剧增。 如图，如果按照 7 4 9 2 5 8 11 的顺</description>
    </item>
    
    <item>
      <title>938. 二叉搜索树的范围和</title>
      <link>https://zhxiongfei.github.io/post/938.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</link>
      <pubDate>Sat, 09 May 2020 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/938.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</guid>
      <description>938. 二叉搜索树的范围和 题解： 二叉树中序遍历， 递加在 [L , R] 范围的元素即可。 思路一： 递归 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 int sum = 0; public int rangeSumBST(TreeNode root, int L, int R){</description>
    </item>
    
    <item>
      <title>二叉搜索树</title>
      <link>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 09 May 2020 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>思考？ 在 n 个动态的整数中搜索某个整数？ (查看其是否存在) 假设用动态数组存放元素，从第0个位置开始遍历搜索，平均时间复杂度 O(N) 如果维护一个有序的</description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>一 树形结构： 数据结构分为线性结构和树形结构，如下图： 线性结构： 树形结构： 生活中的树形结构 二 树(Tree)的基本概念 节点，父节点，子节点，跟节</description>
    </item>
    
    <item>
      <title>队列</title>
      <link>https://zhxiongfei.github.io/post/%E9%98%9F%E5%88%97/</link>
      <pubDate>Sat, 25 Apr 2020 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E9%98%9F%E5%88%97/</guid>
      <description>队列 一，定义 队列是一种特殊的线性表，只能在头尾两端进行操作 队尾(rear) : 只能从队尾添加元素，一般叫做enQueue,入队 对头(front</description>
    </item>
    
    <item>
      <title>集合</title>
      <link>https://zhxiongfei.github.io/post/%E9%9B%86%E5%90%88/</link>
      <pubDate>Wed, 15 Apr 2020 22:20:03 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E9%9B%86%E5%90%88/</guid>
      <description>集合（Set） 集合的定义： 由一个或者多个确定的元素所构成的整体。 特点： 1，不存在重复元素 2，一般用于去重（比如一本书中统计词汇，统计访问网站</description>
    </item>
    
    <item>
      <title>83. 删除排序链表的重复节点</title>
      <link>https://zhxiongfei.github.io/post/83.-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 14 Apr 2020 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/83.-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</guid>
      <description>83. 删除排序链表中的重复元素 题解： 当前节点的值与当前节点next的值相同时，当前节点的.next指向其next.next。 不相同时直接进入下次</description>
    </item>
    
    <item>
      <title>876. 链表的中间节点</title>
      <link>https://zhxiongfei.github.io/post/876.%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 14 Apr 2020 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/876.%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</guid>
      <description>876. 链表的中间结点 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,</description>
    </item>
    
    <item>
      <title>面试题55-1.二叉树的深度</title>
      <link>https://zhxiongfei.github.io/post/55-1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 25 Feb 2020 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/55-1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>面试题55 - I. 二叉树的深度 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长</description>
    </item>
    
    <item>
      <title>35. 搜索插入位置</title>
      <link>https://zhxiongfei.github.io/post/35.-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Mon, 10 Feb 2020 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/35.-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</guid>
      <description>35. 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以</description>
    </item>
    
    <item>
      <title>662.二叉树最大宽度</title>
      <link>https://zhxiongfei.github.io/post/662.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/</link>
      <pubDate>Sat, 25 Jan 2020 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/662.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/</guid>
      <description>662. 二叉树最大宽度 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）</description>
    </item>
    
    <item>
      <title>26.删除排序数组中的重复项</title>
      <link>https://zhxiongfei.github.io/post/26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Sun, 19 Jan 2020 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-</description>
    </item>
    
    <item>
      <title>150. 逆波兰表达式求值</title>
      <link>https://zhxiongfei.github.io/post/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</link>
      <pubDate>Wed, 11 Dec 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</guid>
      <description>150. 逆波兰表达式求值 根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除</description>
    </item>
    
    <item>
      <title>145.二叉树的后序遍历</title>
      <link>https://zhxiongfei.github.io/post/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 25 Nov 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>145. 二叉树的后序遍历 给定一个二叉树，返回它的 后序 遍历。 示例: 输入: [1,null,2,3] 1 2 / 3 输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 来源：力扣</description>
    </item>
    
    <item>
      <title>144.二叉树的前序遍历</title>
      <link>https://zhxiongfei.github.io/post/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 21 Nov 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树的遍历 有两种遍历树的策略： 深度优先搜索(DFS) 在这个策略中，我们采用深度作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根</description>
    </item>
    
    <item>
      <title>235. 二叉搜索树的最近公共祖先</title>
      <link>https://zhxiongfei.github.io/post/235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Tue, 19 Nov 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>235. 二叉搜索树的最近公共祖先 题解： 思路一： 我们使用 HashMap 来存储，子节点的值 -&amp;gt; 父节点。 dfs二叉树，构建map，保存每个节点对应的父节点 根据map，</description>
    </item>
    
    <item>
      <title>450.删除二叉搜索树中的节点</title>
      <link>https://zhxiongfei.github.io/post/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 09 Nov 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>练习题： 450. 删除二叉搜索树中的节点 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回</description>
    </item>
    
    <item>
      <title>98.验证二叉搜索树</title>
      <link>https://zhxiongfei.github.io/post/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Wed, 06 Nov 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>98. 验证二叉搜索树 题解： 迭代 和 递归两种方法思路一样， 都是利用二叉树的中序遍历 二叉搜索树的中序遍历结果，是严格升序的， 所以我们中序遍历二叉树 记录</description>
    </item>
    
    <item>
      <title>142.环形链表II</title>
      <link>https://zhxiongfei.github.io/post/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</link>
      <pubDate>Sat, 26 Oct 2019 18:09:26 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</guid>
      <description>142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接</description>
    </item>
    
    <item>
      <title>349. 两个数组的交集</title>
      <link>https://zhxiongfei.github.io/post/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</link>
      <pubDate>Tue, 15 Oct 2019 22:20:03 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</guid>
      <description>349. 两个数组的交集 给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [9,4] 说明: 输出结果中</description>
    </item>
    
    <item>
      <title>20. 有效的括号</title>
      <link>https://zhxiongfei.github.io/post/20.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Thu, 10 Oct 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/20.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid>
      <description>栈 栈是一种特殊的线性表,只能在一端操作 往栈中添加元素的操作，一般叫做push，入栈 从栈中移除元素的操作，一般叫做pop，出栈（只能移除栈顶元</description>
    </item>
    
    <item>
      <title>88. 合并两个有序数组</title>
      <link>https://zhxiongfei.github.io/post/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 21 Sep 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>88. 合并两个有序数组 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你</description>
    </item>
    
    <item>
      <title>27.移除元素</title>
      <link>https://zhxiongfei.github.io/post/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</link>
      <pubDate>Tue, 03 Sep 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</guid>
      <description>27. 移除元素](https://leetcode-cn.com/problems/remove-element/) 给你一个数组 nums 和一个值 val</description>
    </item>
    
    <item>
      <title>234.回文链表</title>
      <link>https://zhxiongfei.github.io/post/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 26 Aug 2019 18:21:27 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>234. 回文链表 请判断一个链表是否为回文链表。 示例 1: 输入: 1-&amp;gt;2 输出: false 示例 2: 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 来源：</description>
    </item>
    
    <item>
      <title>141.环形链表</title>
      <link>https://zhxiongfei.github.io/post/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 26 Aug 2019 17:58:30 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>141. 环形链表 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -</description>
    </item>
    
    <item>
      <title>17.12.BiNode</title>
      <link>https://zhxiongfei.github.io/post/17.12.binode/</link>
      <pubDate>Sun, 25 Aug 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/17.12.binode/</guid>
      <description>面试题 17.12. BiNode 二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为</description>
    </item>
    
    <item>
      <title>94.二叉树的中序遍历</title>
      <link>https://zhxiongfei.github.io/post/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 25 Aug 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树的遍历 有两种遍历树的策略： 深度优先搜索(DFS) 在这个策略中，我们采用深度作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根</description>
    </item>
    
    <item>
      <title>19.删除链表的倒数第N个节点</title>
      <link>https://zhxiongfei.github.io/post/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 14 Aug 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>19. 删除链表的倒数第N个节点 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2. 当删除了倒数第二个节点</description>
    </item>
    
    <item>
      <title>206.反转链表</title>
      <link>https://zhxiongfei.github.io/post/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 14 Aug 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>206. 反转链表 反转一个单链表。 示例: 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 来源：力扣（LeetCode）</description>
    </item>
    
    <item>
      <title>1. 两数之和</title>
      <link>https://zhxiongfei.github.io/post/1.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Sun, 11 Aug 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/1.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>1. 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会</description>
    </item>
    
    <item>
      <title>2.两数相加</title>
      <link>https://zhxiongfei.github.io/post/2.-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Fri, 26 Jul 2019 16:34:46 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/2.-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>2. 两数相加 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我</description>
    </item>
    
    <item>
      <title>21. 合并两个有序链表</title>
      <link>https://zhxiongfei.github.io/post/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 14 Jul 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>21. 合并两个有序链表 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&amp;gt;2-&amp;</description>
    </item>
    
    <item>
      <title>11.盛最多水的容器</title>
      <link>https://zhxiongfei.github.io/post/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 11 Jul 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
      <description>11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)</description>
    </item>
    
    <item>
      <title>203.移除链表 元素</title>
      <link>https://zhxiongfei.github.io/post/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8-%E5%85%83%E7%B4%A0/</link>
      <pubDate>Fri, 21 Jun 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8-%E5%85%83%E7%B4%A0/</guid>
      <description>203. 移除链表元素 删除链表中等于给定值 *val* 的所有节点。 示例: 1 2 输入: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 题解： 如果删除的是中间节点， 此题看起来非常简单，直接拿到pr</description>
    </item>
    
    <item>
      <title>237. 删除链表中的节点</title>
      <link>https://zhxiongfei.github.io/post/237.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 11 May 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/237.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>链表(Linked List) 动态数组有个明显的缺点，可能会造成内存空间浪费。 链表可以做到用多少就申请多少内存。 链表是一种链式存储的线性表，所有元素的</description>
    </item>
    
    <item>
      <title>108.将有序数组转换成二叉搜索树</title>
      <link>https://zhxiongfei.github.io/post/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Thu, 09 May 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>108. 将有序数组转换为二叉搜索树 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左</description>
    </item>
    
    <item>
      <title>230. 二叉搜索树中第K小的元素</title>
      <link>https://zhxiongfei.github.io/post/230.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 09 May 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/230.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>230. 二叉搜索树中第K小的元素 题解： 二叉搜索树中序遍历的结果，是升序数组， 所以先中序遍历数组，第k个元素即为第k个小的元素。 思路一： 迭代 代码如下</description>
    </item>
    
    <item>
      <title>530.二叉树的最小绝对差</title>
      <link>https://zhxiongfei.github.io/post/530.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</link>
      <pubDate>Thu, 09 May 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/530.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</guid>
      <description>530. 二叉搜索树的最小绝对差 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 题解： 二叉搜索树中序遍历的结果，是</description>
    </item>
    
    <item>
      <title>700.二叉搜索树中的搜索</title>
      <link>https://zhxiongfei.github.io/post/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Thu, 09 May 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</guid>
      <description>700. 二叉搜索树中的搜索 题解： 思路一： 迭代：题目非常简单，普通的二叉搜索树查找。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 二叉搜索树性</description>
    </item>
    
    <item>
      <title>701.二叉搜索树中的插入操作</title>
      <link>https://zhxiongfei.github.io/post/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Thu, 09 May 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</guid>
      <description>701. 二叉搜索树中的插入操作 题解： 二叉搜索树的插入操作非常简单，当val &amp;gt; root.val时，插入root的左子树, 当val &amp;lt; root.val时</description>
    </item>
    
    <item>
      <title>226.翻转二叉树</title>
      <link>https://zhxiongfei.github.io/post/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 26 Apr 2019 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>226. 翻转二叉树 翻转一棵二叉树。 示例： 输入： 4 / 2 7 / \ / 1 3 6 9 输出： 4 / 7 2 / \ / 9 6 3 1 备注: 这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们</description>
    </item>
    
    <item>
      <title>102.二叉树的层序遍历</title>
      <link>https://zhxiongfei.github.io/post/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>102. 二叉树的层序遍历 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例： 二叉树：[3,9,20,nul</description>
    </item>
    
    <item>
      <title>104.二叉树的最大深度</title>
      <link>https://zhxiongfei.github.io/post/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>104. 二叉树的最大深度 题解： 思路一： 使用递归， node节点的高度等于其 max(node.left, node.right) + 1 左右孩子的高度中的较大者 + 1. 代码如下： 1 2 3 4 5 public int maxDepth(TreeNode root){ if (root == null) return</description>
    </item>
    
    <item>
      <title>105.从前序与中序遍历序列构造二叉树</title>
      <link>https://zhxiongfei.github.io/post/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>105. 从前序与中序遍历序列构造二叉树 根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍</description>
    </item>
    
    <item>
      <title>106.从中序与后序遍历构造二叉树</title>
      <link>https://zhxiongfei.github.io/post/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>106. 从中序与后序遍历序列构造二叉树 根据一棵树的中序遍历与后序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍</description>
    </item>
    
    <item>
      <title>114.二叉树展开为链表</title>
      <link>https://zhxiongfei.github.io/post/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid>
      <description>114. 二叉树展开为链表 题解： 思路一： 迭代, 可以发现展开的顺序其实就是二叉树前序遍历。 将左子树插入到右子树 将原来的右子树插入到左子树最右边节点 考虑</description>
    </item>
    
    <item>
      <title>222.完全二叉树的节点个数</title>
      <link>https://zhxiongfei.github.io/post/222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</guid>
      <description>222. 完全二叉树的节点个数 给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每</description>
    </item>
    
    <item>
      <title>225.用队列实现栈</title>
      <link>https://zhxiongfei.github.io/post/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</guid>
      <description>225. 用队列实现栈 使用队列实现栈的下列操作： push(x) &amp;ndash; 元素 x 入栈 pop() &amp;ndash; 移除栈顶元素 top() &amp;ndash; 获取栈顶元素 empty() &amp;ndash; 返回栈是否为空 注意: 你只能使用队列的基本操作&amp;nd</description>
    </item>
    
    <item>
      <title>559.N叉树的最大深度</title>
      <link>https://zhxiongfei.github.io/post/559.n%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/559.n%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>559. N叉树的最大深度 题解： 思路一： 递归，非常容易想的思路，父节点的深度，等于其子节点中最大深度再加一。 代码如下： 1 2 3 4 5 6 7 8 9 10 public int maxDepth(Node root) {</description>
    </item>
    
    <item>
      <title>589.N叉树的前序遍历</title>
      <link>https://zhxiongfei.github.io/post/589.n%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/589.n%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>589. N叉树的前序遍历 题解： 思路一： 递归 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ArrayList list = new ArrayList(); public List&amp;lt;Integer&amp;gt; preorder(Node root) { if (root == null) return list; Node node = root; list.add(node.val); for (int i = 0; i &amp;lt; root.children.size(); i++){ preorder(node.children.get(i)); } return</description>
    </item>
    
    <item>
      <title>590.N叉树的后序遍历</title>
      <link>https://zhxiongfei.github.io/post/590.n%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/590.n%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>590. N叉树的后序遍历 给定一个 N 叉树，返回其节点值的后序遍历。 例如，给定一个 3叉树 : 返回其后序遍历: [5,6,3,2,4,1]. 说明: 递归法很简单，你可以使用迭代法完成此</description>
    </item>
    
    <item>
      <title>202.快乐数</title>
      <link>https://zhxiongfei.github.io/post/202.%E5%BF%AB%E4%B9%90%E6%95%B0/</link>
      <pubDate>Mon, 15 Apr 2019 22:20:03 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/202.%E5%BF%AB%E4%B9%90%E6%95%B0/</guid>
      <description>202. 快乐数 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个</description>
    </item>
    
    <item>
      <title>155. 最小栈</title>
      <link>https://zhxiongfei.github.io/post/155.%E6%9C%80%E5%B0%8F%E6%A0%88/</link>
      <pubDate>Thu, 11 Apr 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/155.%E6%9C%80%E5%B0%8F%E6%A0%88/</guid>
      <description>155. 最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶</description>
    </item>
    
    <item>
      <title>232. 用栈实现队列</title>
      <link>https://zhxiongfei.github.io/post/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Thu, 11 Apr 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>232. 用栈实现队列 使用栈实现队列的下列操作： push(x) &amp;ndash; 将一个元素放入队列的尾部。 pop() &amp;ndash; 从队列首部移除元素。 peek() &amp;ndash; 返回队列首部的元素。 empty() &amp;ndash; 返回队列是否为空。</description>
    </item>
    
    <item>
      <title>字符串常用算法 --&gt; 双指针</title>
      <link>https://zhxiongfei.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Fri, 05 Apr 2019 20:52:54 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
      <description>151. 翻转字符串里的单词 题目 给定一个字符串，逐个反转字符串中的每个单词 示例 1： 1 2 输入: &amp;#34;the sky is blue&amp;#34; 输出: &amp;#34;blue is sky the&amp;#34; 说明： 无空格字符构成一个单词。 输入</description>
    </item>
    
  </channel>
</rss>