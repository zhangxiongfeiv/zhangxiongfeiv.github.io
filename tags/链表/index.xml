<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>链表 on 飞熊&#39;s blogs</title>
    <link>https://zhangxiongfeiv.github.io/tags/%E9%93%BE%E8%A1%A8/</link>
    <description>Recent content in 链表 on 飞熊&#39;s blogs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 03 Jul 2020 14:48:59 +0800</lastBuildDate>
    
	<atom:link href="https://zhangxiongfeiv.github.io/tags/%E9%93%BE%E8%A1%A8/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>约瑟夫环的几种解决方法</title>
      <link>https://zhangxiongfeiv.github.io/post/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 03 Jul 2020 14:48:59 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>约瑟夫问题 本文参考 leetcode大神题解，查看原文 首先我们来了解下，什么是约瑟夫问题？ 这个问题是以弗拉维奥·约瑟夫命名的，他是1世纪的一名</description>
    </item>
    
    <item>
      <title>143.重排链表</title>
      <link>https://zhangxiongfeiv.github.io/post/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 30 Jun 2020 13:31:08 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</guid>
      <description>143. 重排链表 给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯</description>
    </item>
    
    <item>
      <title>24.两两交换链表中的节点</title>
      <link>https://zhangxiongfeiv.github.io/post/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 23 Jun 2020 21:40:25 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>24. 两两交换链表中的节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值</description>
    </item>
    
    <item>
      <title>剑指offer36.二叉搜索树与双向链表</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%89%91%E6%8C%87offer36.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 16 Jun 2020 22:25:37 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%89%91%E6%8C%87offer36.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>面试题36. 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指</description>
    </item>
    
    <item>
      <title>剑指offer.52.两个链表的第一个公共节点</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%89%91%E6%8C%87offer.52.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 02 Jun 2020 21:54:04 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%89%91%E6%8C%87offer.52.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description>面试题52. 两个链表的第一个公共节点 输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：interse</description>
    </item>
    
    <item>
      <title>86.分隔链表</title>
      <link>https://zhangxiongfeiv.github.io/post/86.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 26 May 2020 17:09:30 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/86.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</guid>
      <description>86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对</description>
    </item>
    
    <item>
      <title>02.02链表的倒数第二个节点</title>
      <link>https://zhangxiongfeiv.github.io/post/02.02%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/02.02%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>面试题 02.02. 返回倒数第 k 个节点 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 注意：本题相对原题稍作改动 示例： 输入： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 和 k = 2 输出：</description>
    </item>
    
    <item>
      <title>02.03删除中间节点</title>
      <link>https://zhangxiongfeiv.github.io/post/02.03%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/02.03%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</guid>
      <description>面试题 02.03. 删除中间节点 实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。 示例： 输入</description>
    </item>
    
    <item>
      <title>02.04分割链表</title>
      <link>https://zhangxiongfeiv.github.io/post/02.04%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/02.04%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</guid>
      <description>面试题 02.04. 分割链表 编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(</description>
    </item>
    
    <item>
      <title>02.05链表求和</title>
      <link>https://zhangxiongfeiv.github.io/post/02.05%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/02.05%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/</guid>
      <description>面试题 02.05. 链表求和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 给定两个用链表表示的整数，每个节点包含一个数位。 这些数位是反向存放的，也就是个位</description>
    </item>
    
    <item>
      <title>02.06回文链表</title>
      <link>https://zhangxiongfeiv.github.io/post/02.06%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/02.06%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>面试题 02.06. 回文链表 编写一个函数，检查输入的链表是否是回文的。 示例 1： 输入： 1-&amp;gt;2 输出： false 示例 2： 输入： 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出： true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间</description>
    </item>
    
    <item>
      <title>02.08环路检测</title>
      <link>https://zhangxiongfeiv.github.io/post/02.08%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/02.08%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/</guid>
      <description>面试题 02.08. 环路检测 给定一个有环链表，实现一个算法返回环路的开头节点。 有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则</description>
    </item>
    
    <item>
      <title>83. 删除排序链表的重复节点</title>
      <link>https://zhangxiongfeiv.github.io/post/83.-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 14 Apr 2020 20:33:49 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/83.-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</guid>
      <description>83. 删除排序链表中的重复元素 题解： 当前节点的值与当前节点next的值相同时，当前节点的.next指向其next.next。 不相同时直接进入下次</description>
    </item>
    
    <item>
      <title>876. 链表的中间节点</title>
      <link>https://zhangxiongfeiv.github.io/post/876.%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 14 Apr 2020 20:33:49 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/876.%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</guid>
      <description>876. 链表的中间结点 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,</description>
    </item>
    
    <item>
      <title>142.环形链表II</title>
      <link>https://zhangxiongfeiv.github.io/post/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</link>
      <pubDate>Sat, 26 Oct 2019 18:09:26 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</guid>
      <description>142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接</description>
    </item>
    
    <item>
      <title>234.回文链表</title>
      <link>https://zhangxiongfeiv.github.io/post/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 26 Aug 2019 18:21:27 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>234. 回文链表 请判断一个链表是否为回文链表。 示例 1: 输入: 1-&amp;gt;2 输出: false 示例 2: 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 来源：</description>
    </item>
    
    <item>
      <title>141.环形链表</title>
      <link>https://zhangxiongfeiv.github.io/post/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 26 Aug 2019 17:58:30 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>141. 环形链表 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -</description>
    </item>
    
    <item>
      <title>19.删除链表的倒数第N个节点</title>
      <link>https://zhangxiongfeiv.github.io/post/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 14 Aug 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>19. 删除链表的倒数第N个节点 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2. 当删除了倒数第二个节点</description>
    </item>
    
    <item>
      <title>206.反转链表</title>
      <link>https://zhangxiongfeiv.github.io/post/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 14 Aug 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>206. 反转链表 反转一个单链表。 示例: 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 来源：力扣（LeetCode）</description>
    </item>
    
    <item>
      <title>2.两数相加</title>
      <link>https://zhangxiongfeiv.github.io/post/2.-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Fri, 26 Jul 2019 16:34:46 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/2.-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>2. 两数相加 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我</description>
    </item>
    
    <item>
      <title>21. 合并两个有序链表</title>
      <link>https://zhangxiongfeiv.github.io/post/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 14 Jul 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>21. 合并两个有序链表 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&amp;gt;2-&amp;</description>
    </item>
    
    <item>
      <title>203.移除链表 元素</title>
      <link>https://zhangxiongfeiv.github.io/post/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8-%E5%85%83%E7%B4%A0/</link>
      <pubDate>Fri, 21 Jun 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8-%E5%85%83%E7%B4%A0/</guid>
      <description>203. 移除链表元素 删除链表中等于给定值 *val* 的所有节点。 示例: 1 2 输入: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 题解： 如果删除的是中间节点， 此题看起来非常简单，直接拿到pr</description>
    </item>
    
    <item>
      <title>237. 删除链表中的节点</title>
      <link>https://zhangxiongfeiv.github.io/post/237.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 11 May 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/237.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>链表(Linked List) 动态数组有个明显的缺点，可能会造成内存空间浪费。 链表可以做到用多少就申请多少内存。 链表是一种链式存储的线性表，所有元素的</description>
    </item>
    
  </channel>
</rss>