<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BFS on API调用工程师的进阶</title>
    <link>https://zhxiongfei.github.io/tags/bfs/</link>
    <description>Recent content in BFS on API调用工程师的进阶</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 06 Jun 2020 01:06:51 +0800</lastBuildDate>
    
	<atom:link href="https://zhxiongfei.github.io/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>404.左叶子和</title>
      <link>https://zhxiongfei.github.io/post/404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E5%92%8C/</link>
      <pubDate>Sat, 06 Jun 2020 01:06:51 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E5%92%8C/</guid>
      <description>404. 左叶子之和 计算给定二叉树的所有左叶子之和。 示例： ​ 3 / 9 20 / 15 7 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 来源：力扣（Lee</description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>一 树形结构： 数据结构分为线性结构和树形结构，如下图： 线性结构： 树形结构： 生活中的树形结构 二 树(Tree)的基本概念 节点，父节点，子节点，跟节</description>
    </item>
    
    <item>
      <title>662.二叉树最大宽度</title>
      <link>https://zhxiongfei.github.io/post/662.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/</link>
      <pubDate>Sat, 25 Jan 2020 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/662.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/</guid>
      <description>662. 二叉树最大宽度 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）</description>
    </item>
    
    <item>
      <title>145.二叉树的后序遍历</title>
      <link>https://zhxiongfei.github.io/post/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 25 Nov 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>145. 二叉树的后序遍历 给定一个二叉树，返回它的 后序 遍历。 示例: 输入: [1,null,2,3] 1 2 / 3 输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 来源：力扣</description>
    </item>
    
    <item>
      <title>144.二叉树的前序遍历</title>
      <link>https://zhxiongfei.github.io/post/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 21 Nov 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树的遍历 有两种遍历树的策略： 深度优先搜索(DFS) 在这个策略中，我们采用深度作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根</description>
    </item>
    
    <item>
      <title>94.二叉树的中序遍历</title>
      <link>https://zhxiongfei.github.io/post/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 25 Aug 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树的遍历 有两种遍历树的策略： 深度优先搜索(DFS) 在这个策略中，我们采用深度作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根</description>
    </item>
    
    <item>
      <title>226.翻转二叉树</title>
      <link>https://zhxiongfei.github.io/post/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 26 Apr 2019 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>226. 翻转二叉树 翻转一棵二叉树。 示例： 输入： 4 / 2 7 / \ / 1 3 6 9 输出： 4 / 7 2 / \ / 9 6 3 1 备注: 这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们</description>
    </item>
    
    <item>
      <title>102.二叉树的层序遍历</title>
      <link>https://zhxiongfei.github.io/post/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>102. 二叉树的层序遍历 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例： 二叉树：[3,9,20,nul</description>
    </item>
    
    <item>
      <title>104.二叉树的最大深度</title>
      <link>https://zhxiongfei.github.io/post/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>104. 二叉树的最大深度 题解： 思路一： 使用递归， node节点的高度等于其 max(node.left, node.right) + 1 左右孩子的高度中的较大者 + 1. 代码如下： 1 2 3 4 5 public int maxDepth(TreeNode root){ if (root == null) return</description>
    </item>
    
    <item>
      <title>105.从前序与中序遍历序列构造二叉树</title>
      <link>https://zhxiongfei.github.io/post/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>105. 从前序与中序遍历序列构造二叉树 根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍</description>
    </item>
    
    <item>
      <title>114.二叉树展开为链表</title>
      <link>https://zhxiongfei.github.io/post/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid>
      <description>114. 二叉树展开为链表 题解： 思路一： 迭代, 可以发现展开的顺序其实就是二叉树前序遍历。 将左子树插入到右子树 将原来的右子树插入到左子树最右边节点 考虑</description>
    </item>
    
    <item>
      <title>589.N叉树的前序遍历</title>
      <link>https://zhxiongfei.github.io/post/589.n%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/589.n%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>589. N叉树的前序遍历 题解： 思路一： 递归 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ArrayList list = new ArrayList(); public List&amp;lt;Integer&amp;gt; preorder(Node root) { if (root == null) return list; Node node = root; list.add(node.val); for (int i = 0; i &amp;lt; root.children.size(); i++){ preorder(node.children.get(i)); } return</description>
    </item>
    
    <item>
      <title>590.N叉树的后序遍历</title>
      <link>https://zhxiongfei.github.io/post/590.n%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/590.n%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>590. N叉树的后序遍历 给定一个 N 叉树，返回其节点值的后序遍历。 例如，给定一个 3叉树 : 返回其后序遍历: [5,6,3,2,4,1]. 说明: 递归法很简单，你可以使用迭代法完成此</description>
    </item>
    
  </channel>
</rss>