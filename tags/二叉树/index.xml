<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>二叉树 on 飞熊&#39;s Blogs</title>
    <link>https://zhangxiongfeiv.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
    <description>Recent content in 二叉树 on 飞熊&#39;s Blogs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 16 Jun 2020 22:25:37 +0800</lastBuildDate>
    
	<atom:link href="https://zhangxiongfeiv.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>剑指offer36.二叉搜索树与双向链表</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%89%91%E6%8C%87offer36.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 16 Jun 2020 22:25:37 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%89%91%E6%8C%87offer36.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>面试题36. 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指</description>
    </item>
    
    <item>
      <title>404.左叶子和</title>
      <link>https://zhangxiongfeiv.github.io/post/404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E5%92%8C/</link>
      <pubDate>Sat, 06 Jun 2020 01:06:51 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E5%92%8C/</guid>
      <description>404. 左叶子之和 计算给定二叉树的所有左叶子之和。 示例： ​ 3 / 9 20 / 15 7 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 来源：力扣（Lee</description>
    </item>
    
    <item>
      <title>04.02最小高度树</title>
      <link>https://zhangxiongfeiv.github.io/post/04.02%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/04.02%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</guid>
      <description>面试题 04.02. 最小高度树 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能</description>
    </item>
    
    <item>
      <title>04.03特定深度节点链表</title>
      <link>https://zhangxiongfeiv.github.io/post/04.03%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/04.03%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/</guid>
      <description>面试题 04.03. 特定深度节点链表 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回</description>
    </item>
    
    <item>
      <title>04.05合法二叉搜索树</title>
      <link>https://zhangxiongfeiv.github.io/post/04.05%E5%90%88%E6%B3%95%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/04.05%E5%90%88%E6%B3%95%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>面试题 04.05. 合法二叉搜索树 实现一个函数，检查一棵二叉树是否为二叉搜索树。 示例 1: 输入: 2 / 1 3 输出: true 示例 2: 输入: 5 / 1 4 / 3 6 输出: false 解释: 输入</description>
    </item>
    
    <item>
      <title>04.06后继者</title>
      <link>https://zhangxiongfeiv.github.io/post/04.06%E5%90%8E%E7%BB%A7%E8%80%85/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/04.06%E5%90%8E%E7%BB%A7%E8%80%85/</guid>
      <description>面试题 04.06. 后继者 设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。 如果指定节点没有对应的“下一个”节点，则返回null。</description>
    </item>
    
    <item>
      <title>04.08首个公共祖先</title>
      <link>https://zhangxiongfeiv.github.io/post/04.08%E9%A6%96%E4%B8%AA%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/04.08%E9%A6%96%E4%B8%AA%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>面试题 04.08. 首个共同祖先 设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉</description>
    </item>
    
    <item>
      <title>04.10检查子树</title>
      <link>https://zhangxiongfeiv.github.io/post/04.10%E6%A3%80%E6%9F%A5%E5%AD%90%E6%A0%91/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/04.10%E6%A3%80%E6%9F%A5%E5%AD%90%E6%A0%91/</guid>
      <description>面试题 04.10. 检查子树 检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。 如果 T1 有这么一</description>
    </item>
    
    <item>
      <title>110.平衡二叉树</title>
      <link>https://zhangxiongfeiv.github.io/post/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值</description>
    </item>
    
    <item>
      <title>AVL树</title>
      <link>https://zhangxiongfeiv.github.io/post/avl%E6%A0%91/</link>
      <pubDate>Mon, 11 May 2020 21:04:44 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/avl%E6%A0%91/</guid>
      <description>AVL树 平衡因子(Balance Factor): 某节点左右子树的高度差 AVL树的特点 每个节点的平衡因子只可能是1, 0, -1(绝对值 &amp;lt;= 1, 如果超过1，称之为 &amp;l</description>
    </item>
    
    <item>
      <title>平衡二叉搜索树</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Mon, 11 May 2020 21:03:47 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>平衡二叉搜索树 (BBST) 二叉搜索树(BST)的缺陷？ 二叉搜索树，在某种情况下会导致极度的不平衡，导致时间复杂度剧增。 如图，如果按照 7 4 9 2 5 8 11 的顺</description>
    </item>
    
    <item>
      <title>938. 二叉搜索树的范围和</title>
      <link>https://zhangxiongfeiv.github.io/post/938.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</link>
      <pubDate>Sat, 09 May 2020 21:35:41 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/938.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</guid>
      <description>938. 二叉搜索树的范围和 题解： 二叉树中序遍历， 递加在 [L , R] 范围的元素即可。 思路一： 递归 代码如下： int sum = 0; public int rangeSumBST(TreeNode root, int L, int R){ if (root == null) return 0; rangeSumBST(root.left, L ,R); if (root.val &amp;gt;=</description>
    </item>
    
    <item>
      <title>二叉搜索树</title>
      <link>https://zhangxiongfeiv.github.io/post/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 09 May 2020 21:35:41 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>思考？ 在 n 个动态的整数中搜索某个整数？ (查看其是否存在) 假设用动态数组存放元素，从第0个位置开始遍历搜索，平均时间复杂度 O(N) 如果维护一个有序的</description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://zhangxiongfeiv.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>一 树形结构： 数据结构分为线性结构和树形结构，如下图： 线性结构： 树形结构： 生活中的树形结构 二 树(Tree)的基本概念 节点，父节点，子节点，跟节</description>
    </item>
    
    <item>
      <title>面试题55-1.二叉树的深度</title>
      <link>https://zhangxiongfeiv.github.io/post/55-1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 25 Feb 2020 18:25:18 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/55-1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>面试题55 - I. 二叉树的深度 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长</description>
    </item>
    
    <item>
      <title>662.二叉树最大宽度</title>
      <link>https://zhangxiongfeiv.github.io/post/662.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/</link>
      <pubDate>Sat, 25 Jan 2020 18:25:18 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/662.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/</guid>
      <description>662. 二叉树最大宽度 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）</description>
    </item>
    
    <item>
      <title>145.二叉树的后序遍历</title>
      <link>https://zhangxiongfeiv.github.io/post/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 25 Nov 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>145. 二叉树的后序遍历 给定一个二叉树，返回它的 后序 遍历。 示例: 输入: [1,null,2,3] 1 2 / 3 输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 来源：力扣</description>
    </item>
    
    <item>
      <title>144.二叉树的前序遍历</title>
      <link>https://zhangxiongfeiv.github.io/post/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 21 Nov 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树的遍历 有两种遍历树的策略： 深度优先搜索(DFS) 在这个策略中，我们采用深度作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根</description>
    </item>
    
    <item>
      <title>235. 二叉搜索树的最近公共祖先</title>
      <link>https://zhangxiongfeiv.github.io/post/235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Tue, 19 Nov 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>235. 二叉搜索树的最近公共祖先 题解： 思路一： 我们使用 HashMap 来存储，子节点的值 -&amp;gt; 父节点。 dfs二叉树，构建map，保存每个节点对应的父节点 根据map，</description>
    </item>
    
    <item>
      <title>450.删除二叉搜索树中的节点</title>
      <link>https://zhangxiongfeiv.github.io/post/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 09 Nov 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>练习题： 450. 删除二叉搜索树中的节点 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回</description>
    </item>
    
  </channel>
</rss>