<!doctype html>
<html lang="en-us">
  <head>
    <title>字符串常用算法 --&gt; 滑动窗口 // 张雄飞</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.68.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="张雄飞" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://zhangxiongfeiv.github.io/css/main.min.61bb32028587f24ca28522d8d197970c7ef33284e5fffb45a75fcbbb2dbc4dcb.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="字符串常用算法 --&gt; 滑动窗口"/>
<meta name="twitter:description" content="字符串算法之滑动窗口 题目 3. 无重复字符的最长子串  给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: &ldquo;abcabcbb&rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 &ldquo;abc&rdquo;，所以其长度为 3。 示例 2:
输入: &ldquo;bbbbb&rdquo; 输出: 1 解释: 因为无重复字符的最长子串是 &ldquo;b&rdquo;，所以其长度为 1。 示例 3:
输入: &ldquo;pwwkew&rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 &ldquo;wke&rdquo;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&ldquo;pwke&rdquo; 是一个子序列，不是子串。
 解题思路 此题采用滑动窗口解题方法，将一个hashmap作为窗口，map中key，value分别为，字符和字符所在的index。
两个指针，left指针是便利时不重复字串的起点。 i指针是当前遍历的index。
max用来存储最终结果，即无重复字串的长度。
一遍循环，循环时有如下情况：
1，当map的key中不包含当前遍历的字符时，将其加入窗口中（即加入map中，设置map的key为当前字符，value为当前index）。
2，当map中的key包含当前遍历的字符时，滑动窗口滑动至包含字符对应value（即index）的下一个,并且需要将left到index之间的key清除掉。 然后其加入窗口中。
3，上述两种情况都分别计算，当前不重复字串的长度。 max = Math.max(max, i - left &#43; 1);
代码如下 public static int lengthOfLongestSubstring(String s) { if (s == null || s."/>

    <meta property="og:title" content="字符串常用算法 --&gt; 滑动窗口" />
<meta property="og:description" content="字符串算法之滑动窗口 题目 3. 无重复字符的最长子串  给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: &ldquo;abcabcbb&rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 &ldquo;abc&rdquo;，所以其长度为 3。 示例 2:
输入: &ldquo;bbbbb&rdquo; 输出: 1 解释: 因为无重复字符的最长子串是 &ldquo;b&rdquo;，所以其长度为 1。 示例 3:
输入: &ldquo;pwwkew&rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 &ldquo;wke&rdquo;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&ldquo;pwke&rdquo; 是一个子序列，不是子串。
 解题思路 此题采用滑动窗口解题方法，将一个hashmap作为窗口，map中key，value分别为，字符和字符所在的index。
两个指针，left指针是便利时不重复字串的起点。 i指针是当前遍历的index。
max用来存储最终结果，即无重复字串的长度。
一遍循环，循环时有如下情况：
1，当map的key中不包含当前遍历的字符时，将其加入窗口中（即加入map中，设置map的key为当前字符，value为当前index）。
2，当map中的key包含当前遍历的字符时，滑动窗口滑动至包含字符对应value（即index）的下一个,并且需要将left到index之间的key清除掉。 然后其加入窗口中。
3，上述两种情况都分别计算，当前不重复字串的长度。 max = Math.max(max, i - left &#43; 1);
代码如下 public static int lengthOfLongestSubstring(String s) { if (s == null || s." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhangxiongfeiv.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" />
<meta property="article:published_time" content="2020-04-06T21:16:57+08:00" />
<meta property="article:modified_time" content="2020-04-06T21:16:57+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://zhangxiongfeiv.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="张雄飞" /></a>
      <h1>张雄飞</h1>
      <p>iOS Developer, 喜欢逆向, 喜欢刷题...</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">字符串常用算法 --&gt; 滑动窗口</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 6, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div></div>
    </header>
    <div class="post-content">
      <h2 id="字符串算法之滑动窗口">字符串算法之滑动窗口</h2>
<h3 id="题目">题目</h3>
<h3 id="3-无重复字符的最长子串httpsleetcode-cncomproblemslongest-substring-without-repeating-characters"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3>
<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: &ldquo;abcabcbb&rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &ldquo;abc&rdquo;，所以其长度为 3。
示例 2:</p>
<p>输入: &ldquo;bbbbb&rdquo;
输出: 1
解释: 因为无重复字符的最长子串是 &ldquo;b&rdquo;，所以其长度为 1。
示例 3:</p>
<p>输入: &ldquo;pwwkew&rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &ldquo;wke&rdquo;，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，&ldquo;pwke&rdquo; 是一个子序列，不是子串。</p>
</blockquote>
<h3 id="解题思路">解题思路</h3>
<p>此题采用滑动窗口解题方法，将一个hashmap作为窗口，map中key，value分别为，字符和字符所在的index。</p>
<p>两个指针，left指针是便利时不重复字串的起点。 i指针是当前遍历的index。</p>
<p>max用来存储最终结果，即无重复字串的长度。</p>
<p>一遍循环，循环时有如下情况：</p>
<p>1，当map的key中不包含当前遍历的字符时，将其加入窗口中（即加入map中，设置map的key为当前字符，value为当前index）。</p>
<p>2，当map中的key包含当前遍历的字符时，滑动窗口滑动至包含字符对应value（即index）的下一个,并且需要将left到index之间的key清除掉。 然后其加入窗口中。</p>
<p>3，上述两种情况都分别计算，当前不重复字串的长度。 max = Math.max(max, i - left + 1);</p>
<h3 id="代码如下">代码如下</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lengthOfLongestSubstring</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>

        <span style="color:#75715e">// map key是字符，value是字符出现的index
</span><span style="color:#75715e"></span>        HashMap<span style="color:#f92672">&lt;</span>Character<span style="color:#f92672">,</span>Integer<span style="color:#f92672">&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#75715e">// max 记录最终结果， left记录滑动窗口的最左端.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> left <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>map<span style="color:#f92672">.</span><span style="color:#a6e22e">containsKey</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">))){</span>
              	<span style="color:#75715e">// 包含时，需要先将left到i之间 ，map包含的key清除
</span><span style="color:#75715e"></span>               	<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> left<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">));</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                    map<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>j<span style="color:#f92672">));</span>
                <span style="color:#f92672">}</span>
                <span style="color:#75715e">// 然后left向右滑动
</span><span style="color:#75715e"></span>                left <span style="color:#f92672">=</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">))</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 将现有值加入map
</span><span style="color:#75715e"></span>            map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">),</span>i<span style="color:#f92672">);</span>
            <span style="color:#75715e">// 计算现在窗口宽度 和 之前最大值的较大者.
</span><span style="color:#75715e"></span>            max <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>max<span style="color:#f92672">,</span>i<span style="color:#f92672">-</span>left<span style="color:#f92672">+</span>1<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> max<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

</code></pre></div><h3 id="算法优化">算法优化=====&gt;</h3>
<p>上述做法，包含时，需要先将left到i之间 ，需要将map包含的key清除。以便下次取出value时，避免的字串的影响。</p>
<p>故做一下优化， 当包含时，如果map中取出的值比left小，则认为无效，即当作不包含情况处理。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>map<span style="color:#f92672">.</span><span style="color:#a6e22e">containsKey</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">))</span> <span style="color:#f92672">&amp;&amp;</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;=</span> left<span style="color:#f92672">){</span>
	  left <span style="color:#f92672">=</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">))</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>优化过后，leetcode时间消耗从13ms优化至9ms。</p>
<h4 id="239-滑动窗口最大值httpsleetcode-cncomproblemssliding-window-maximum"><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4>
<blockquote>
<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>进阶：</p>
<p>你能在线性时间复杂度内解决此题吗？</p>
<p>示例:</p>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]
解释:</p>
<p>滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3
1 [3  -1  -3] 5  3  6  7       3
1  3 [-1  -3  5] 3  6  7       5
1  3  -1 [-3  5  3] 6  7       5
1  3  -1  -3 [5  3  6] 7       6
1  3  -1  -3  5 [3  6  7]      7</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 10^5
-10^4 &lt;= nums[i] &lt;= 10^4
1 &lt;= k &lt;= nums.length</p>
</blockquote>
<h3 id="解题思路-1">解题思路</h3>
<p>整体思路，利用双端队列,队列中存放下标, 对头存放最大值的下标，新进来一个元素，从队尾开始while循环比较，当比队尾元素大时，移除队尾元素，当队列为空，或者找到队列中元素比当前元素大时结束循环，并将当前元素插入队尾。</p>
<p>当队列对头存放的下标，不在滑动窗口范围即 &lt; begain时，队头元素出队列</p>
<p>当下标有效即下标 &gt;= 0 时， 开始拿出队列头部元素放入 maxes结果数组中.</p>
<p>经过一遍循环，时间复杂度O(n)
需要额外k个元素大小的双端队列，空间复杂度O(k).</p>
<h3 id="代码如下-1">代码如下</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">maxSlidingWindow</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> k<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nums <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> k <span style="color:#f92672">&lt;</span> 1<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>k <span style="color:#f92672">==</span> 1<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> nums<span style="color:#f92672">;</span>

        <span style="color:#75715e">// 存放滑动窗口最大值数组
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> maxes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> k <span style="color:#f92672">+</span> 1<span style="color:#f92672">];</span>

        <span style="color:#75715e">// 双端队列 存放数组的下标
</span><span style="color:#75715e"></span>        Deque<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>

            <span style="color:#75715e">// 循环从尾部开始比较，比尾部元素小时，移除尾部元素
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span><span style="color:#f92672">(!</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;=</span> nums<span style="color:#f92672">[</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">peekLast</span><span style="color:#f92672">()]){</span>
                queue<span style="color:#f92672">.</span><span style="color:#a6e22e">removeLast</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>

            <span style="color:#75715e">// 讲当前元素加入队尾（也有可能是队头，当前元素比之前对头元素还大时）
</span><span style="color:#75715e"></span>            queue<span style="color:#f92672">.</span><span style="color:#a6e22e">addLast</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>

            <span style="color:#75715e">// begain 就是结果元素的下标
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> begain <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> k <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>

            <span style="color:#75715e">// 取出对头元素，即最大值下标，当下标无效（ &lt; begain） 时，将其移除
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">peekFirst</span><span style="color:#f92672">()</span> <span style="color:#f92672">&lt;</span> begain<span style="color:#f92672">){</span>
                queue<span style="color:#f92672">.</span><span style="color:#a6e22e">removeFirst</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>

            <span style="color:#75715e">// begain有效，即&gt;=0时，赋值
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>begain <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">){</span>
                maxes<span style="color:#f92672">[</span>begain<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">peekFirst</span><span style="color:#f92672">()];</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> maxes<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
