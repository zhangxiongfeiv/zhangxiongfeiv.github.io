<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 飞熊&#39;s Blogs</title>
    <link>https://zhangxiongfeiv.github.io/post/</link>
    <description>Recent content in Posts on 飞熊&#39;s Blogs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 02 Jun 2020 21:54:04 +0800</lastBuildDate>
    
	<atom:link href="https://zhangxiongfeiv.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>leetcode200题回顾与总结</title>
      <link>https://zhangxiongfeiv.github.io/post/leetcode200%E9%A2%98%E5%9B%9E%E9%A1%BE/</link>
      <pubDate>Thu, 28 May 2020 10:09:44 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/leetcode200%E9%A2%98%E5%9B%9E%E9%A1%BE/</guid>
      <description>2020.5.27总结 截止 5.27日，leetcode总刷题数到达200，写一篇文章以回顾，总结。 起因 非计算机专业出身的程序员, 经历过很多因</description>
    </item>
    
    <item>
      <title>剑指offer.52.两个链表的第一个公共节点</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%89%91%E6%8C%87offer.52.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 02 Jun 2020 21:54:04 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%89%91%E6%8C%87offer.52.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description>面试题52. 两个链表的第一个公共节点 输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：interse</description>
    </item>
    
    <item>
      <title>剑指offer.60.n个骰子的点数</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%89%91%E6%8C%87offer.60.n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</link>
      <pubDate>Tue, 02 Jun 2020 21:52:35 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%89%91%E6%8C%87offer.60.n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</guid>
      <description>面试题60. n个骰子的点数 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数</description>
    </item>
    
    <item>
      <title>剑指offer.68.二叉树的最近公共祖先</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%89%91%E6%8C%87offer.68.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Tue, 02 Jun 2020 21:51:04 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%89%91%E6%8C%87offer.68.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>面试题68 - I. 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树</description>
    </item>
    
    <item>
      <title>415.字符串相加</title>
      <link>https://zhangxiongfeiv.github.io/post/415.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Mon, 01 Jun 2020 22:23:54 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/415.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</guid>
      <description>415. 字符串相加 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100. num1 和num2 都只包含数字 0-9. num1 和num2 都</description>
    </item>
    
    <item>
      <title>儿童节快乐-来自leetcode友好的祝福</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%84%BF%E7%AB%A5%E8%8A%82%E5%BF%AB%E4%B9%90-%E6%9D%A5%E8%87%AAleetcode%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%A5%9D%E7%A6%8F/</link>
      <pubDate>Mon, 01 Jun 2020 17:47:30 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%84%BF%E7%AB%A5%E8%8A%82%E5%BF%AB%E4%B9%90-%E6%9D%A5%E8%87%AAleetcode%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%A5%9D%E7%A6%8F/</guid>
      <description>6.1儿童节 今天是6.1儿童节, 今日份 leetcode 每日一题非常友好 , 可以说是儿童节福利题. 1431. 拥有最多糖果的孩子 给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第</description>
    </item>
    
    <item>
      <title>归并排序</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 31 May 2020 17:42:58 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>归并排序(merge sort) 于1945年，由冯诺伊曼提出首次提出 执行流程 不断地将数组平均分割成两个子序列, 直到不能再分割为止(只有一个元素) 不断地</description>
    </item>
    
    <item>
      <title>40.最小的k个数</title>
      <link>https://zhangxiongfeiv.github.io/post/40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Sat, 30 May 2020 23:50:40 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</guid>
      <description>面试题40. 最小的k个数 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、</description>
    </item>
    
    <item>
      <title>团灭丑数问题</title>
      <link>https://zhangxiongfeiv.github.io/post/%E5%9B%A2%E7%81%AD%E4%B8%91%E6%95%B0%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 30 May 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E5%9B%A2%E7%81%AD%E4%B8%91%E6%95%B0%E9%97%AE%E9%A2%98/</guid>
      <description>什么是丑数？ 先看一下百度百科的解释: 说法一（ugly number）：把只包含质因子2，3和5的数称作丑数（Ugly Number）。例如6、8</description>
    </item>
    
    <item>
      <title>二叉堆</title>
      <link>https://zhangxiongfeiv.github.io/post/%E4%BA%8C%E5%8F%89%E5%A0%86/</link>
      <pubDate>Fri, 29 May 2020 17:27:40 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/%E4%BA%8C%E5%8F%89%E5%A0%86/</guid>
      <description>二叉堆 概念 堆是一个可以被看作近似完全二叉树的数组。树上的每一个节点对应数组的一个元素。出了最底层外，该树是完全充满的，而且是从左到右填充哦。</description>
    </item>
    
    <item>
      <title>01.08零矩阵</title>
      <link>https://zhangxiongfeiv.github.io/post/01.08%E9%9B%B6%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Thu, 28 May 2020 22:55:05 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/01.08%E9%9B%B6%E7%9F%A9%E9%98%B5/</guid>
      <description>面试题 01.08. 零矩阵 编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。 示例 1： 输入： [ [1,1,1], [1,0,1], [1,1,1] ] 输出： [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2： 输入： [ [0,1,2,0], [3,4,5,2],</description>
    </item>
    
    <item>
      <title>01.07旋转矩阵</title>
      <link>https://zhangxiongfeiv.github.io/post/01.07%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Thu, 28 May 2020 22:52:33 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/01.07%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</guid>
      <description>面试题 01.07. 旋转矩阵 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。 不占用额外内存空间能否做到？ 示</description>
    </item>
    
    <item>
      <title>01.06字符串压缩</title>
      <link>https://zhangxiongfeiv.github.io/post/01.06%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</link>
      <pubDate>Thu, 28 May 2020 22:37:48 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/01.06%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</guid>
      <description>面试题 01.06. 字符串压缩 字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b</description>
    </item>
    
    <item>
      <title>01.05一次编辑</title>
      <link>https://zhangxiongfeiv.github.io/post/01.05%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/</link>
      <pubDate>Thu, 28 May 2020 22:32:11 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/01.05%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/</guid>
      <description>面试题 01.05. 一次编辑 字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零</description>
    </item>
    
    <item>
      <title>01.04.回文排列</title>
      <link>https://zhangxiongfeiv.github.io/post/01.04%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97/</link>
      <pubDate>Thu, 28 May 2020 22:27:06 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/01.04%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97/</guid>
      <description>面试题 01.04. 回文排列 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。 回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排</description>
    </item>
    
    <item>
      <title>01.03URL化</title>
      <link>https://zhangxiongfeiv.github.io/post/01.03url%E5%8C%96/</link>
      <pubDate>Thu, 28 May 2020 22:22:18 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/01.03url%E5%8C%96/</guid>
      <description>面试题 01.03. URL化 URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”</description>
    </item>
    
    <item>
      <title>01.02判断是否互为字符重排</title>
      <link>https://zhangxiongfeiv.github.io/post/01.02%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/</link>
      <pubDate>Thu, 28 May 2020 22:18:56 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/01.02%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/</guid>
      <description>面试题 01.02. 判定是否互为字符重排 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。 示例 1： 输入:</description>
    </item>
    
    <item>
      <title>01.01判断字符是否唯一</title>
      <link>https://zhangxiongfeiv.github.io/post/01.01%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</link>
      <pubDate>Thu, 28 May 2020 22:15:10 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/01.01%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</guid>
      <description>面试题 01.01. 判定字符是否唯一 实现一个算法，确定一个字符串 s 的所有字符是否全都不同。 示例 1： 输入: s = &amp;ldquo;leetcode&amp;rdquo; 输出: false 示例 2： 输入: s = &amp;ldquo;abc&amp;rdquo; 输出: true 限制：</description>
    </item>
    
    <item>
      <title>1248.统计优美子数组</title>
      <link>https://zhangxiongfeiv.github.io/post/1248.%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 27 May 2020 17:09:19 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/1248.%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>1248. 统计「优美子数组」 此题同 560, 974解题思路一致，复习时，可以一块看。 标签前序和。一并看懂前序和的问题。 给你一个整数数组 nums 和一个整数 k。 如果某</description>
    </item>
    
    <item>
      <title>560.和为K的子数组</title>
      <link>https://zhangxiongfeiv.github.io/post/560.%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 27 May 2020 14:12:36 +0800</pubDate>
      
      <guid>https://zhangxiongfeiv.github.io/post/560.%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>560. 和为K的子数组 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1]</description>
    </item>
    
  </channel>
</rss>