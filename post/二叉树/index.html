<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>二叉树 - 飞熊&#39;s Blogs=&#39;</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="飞熊" />
  <meta name="description" content="一 树形结构： 数据结构分为线性结构和树形结构，如下图： 线性结构： 树形结构： 生活中的树形结构 二 树(Tree)的基本概念 节点，父节点，子节点，跟节" />

  <meta name="keywords" content="Hugo, theme, jane" />






<meta name="generator" content="Hugo 0.68.3" />


<link rel="canonical" href="https://zhangxiongfeiv.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.fa3d941d1d0e0ddc985804227feabffea55c89883eb0af34e0532a7ae9135151.css" integrity="sha256-&#43;j2UHR0ODdyYWAQif&#43;q//qVciYg&#43;sK804FMqeukTUVE=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="二叉树" />
<meta property="og:description" content="一 树形结构： 数据结构分为线性结构和树形结构，如下图： 线性结构： 树形结构： 生活中的树形结构 二 树(Tree)的基本概念 节点，父节点，子节点，跟节" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhangxiongfeiv.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91/" />
<meta property="article:published_time" content="2020-04-26T10:15:13+08:00" />
<meta property="article:modified_time" content="2020-04-26T10:15:13+08:00" />
<meta itemprop="name" content="二叉树">
<meta itemprop="description" content="一 树形结构： 数据结构分为线性结构和树形结构，如下图： 线性结构： 树形结构： 生活中的树形结构 二 树(Tree)的基本概念 节点，父节点，子节点，跟节">
<meta itemprop="datePublished" content="2020-04-26T10:15:13&#43;08:00" />
<meta itemprop="dateModified" content="2020-04-26T10:15:13&#43;08:00" />
<meta itemprop="wordCount" content="9814">



<meta itemprop="keywords" content="二叉树,BFS," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="二叉树"/>
<meta name="twitter:description" content="一 树形结构： 数据结构分为线性结构和树形结构，如下图： 线性结构： 树形结构： 生活中的树形结构 二 树(Tree)的基本概念 节点，父节点，子节点，跟节"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Jane</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://zhangxiongfeiv.github.io/">This is Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://zhangxiongfeiv.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://zhangxiongfeiv.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://zhangxiongfeiv.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://zhangxiongfeiv.github.io/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Jane
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://zhangxiongfeiv.github.io/">This is Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://zhangxiongfeiv.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://zhangxiongfeiv.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://zhangxiongfeiv.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://zhangxiongfeiv.github.io/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">二叉树</h1>
      
      <div class="post-meta">
        <time datetime="2020-04-26" class="post-time">
          2020-04-26
        </time>
        
        

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一-树形结构">一 树形结构：</a></li>
    <li><a href="#二-树tree的基本概念">二 树(Tree)的基本概念</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#二叉树binary-tree">二叉树（Binary Tree）</a>
      <ul>
        <li><a href="#二叉树的特点">二叉树的特点：</a></li>
        <li><a href="#二叉树的性质">二叉树的性质：</a></li>
        <li><a href="#真二叉树proper-binary-tree">真二叉树(Proper Binary Tree)：</a></li>
        <li><a href="#满二叉树full-binary-tree">满二叉树(Full Binary Tree)：</a></li>
        <li><a href="#完全二叉树">完全二叉树</a></li>
        <li><a href="#二叉树的遍历">二叉树的遍历</a></li>
        <li><a href="#截屏2020-04-26下午12811httpstva1sinaimgcnlarge007s8zilly1ge73td82tfj30sc0h00vyjpg"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge73td82tfj30sc0h00vy.jpg" alt="截屏2020-04-26下午1.28.11"></a></li>
        <li><a href="#练习题">练习题</a></li>
        <li><a href="#二叉树">二叉树</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6yefv494j30k00jy76o.jpg" alt="截屏2020-04-26上午10.17.34"></p>
<h2 id="一-树形结构">一 树形结构：</h2>
<p>数据结构分为线性结构和树形结构，如下图：</p>
<ul>
<li>线性结构：</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6yd4dsu4j30bq09qq34.jpg" alt="截屏2020-04-26上午10.17.20"></p>
<ul>
<li>树形结构：</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6ydz49xgj30xa0euq4l.jpg" alt="截屏2020-04-26上午10.17.28"></p>
<ul>
<li>
<p>生活中的树形结构</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6ygcd2dxj31140ng41w.jpg" alt="截屏2020-04-26上午10.17.55"></p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6ygo4xu0j30cq0gwq3r.jpg" alt="截屏2020-04-26上午10.18.01"></p>
<h2 id="二-树tree的基本概念">二 树(Tree)的基本概念</h2>
<ul>
<li>
<p>节点，父节点，子节点，跟节点，兄弟节点</p>
</li>
<li>
<p>一棵树可以没有任何节点，成为空树</p>
</li>
<li>
<p>一棵树可以只有一个节点，也就是跟节点</p>
</li>
<li>
<p>子树，左子树，右子树</p>
</li>
<li>
<p>节点的度：子树的个数</p>
</li>
<li>
<p>树的度：所有接点度中的最大值</p>
</li>
<li>
<p>叶子节点leaf：度为0的节点</p>
</li>
<li>
<p>非叶子节点： 度不为0的节点</p>
</li>
<li>
<p>层数：根节点在第一层，根节点的字节点在第二层，以此类推</p>
</li>
<li>
<p>节点的深度：从根节点到当前节点的节点总数</p>
</li>
<li>
<p>节点的高度：从当前节点到最远叶子节点的路径上的节点总数</p>
</li>
<li>
<p>树的深度：所有节点深度中的最大值</p>
</li>
<li>
<p>树的高度：所有节点高度中的最大值</p>
</li>
<li>
<p>树的深度等于树的高度</p>
</li>
</ul>
<h4 id="有序树无序树森林">有序树，无序树，森林</h4>
<ul>
<li>有序树：树中任意节点的字节点有顺序关系</li>
<li>无序树：树中任意节点的字节点没有顺序关系，也成为自由树</li>
<li>森林：由m(m &gt;= 0) 棵互不相交的树组成的集合</li>
</ul>
<h2 id="二叉树binary-tree">二叉树（Binary Tree）</h2>
<h3 id="二叉树的特点">二叉树的特点：</h3>
<ul>
<li>每个节点的度最大为2（最多拥有两棵子树）</li>
<li>左子树和右子树是有顺序的</li>
<li>即使某一节点只有一棵树，也要区分左右子树</li>
<li>有序树</li>
</ul>
<h3 id="二叉树的性质">二叉树的性质：</h3>
<ul>
<li>
<p>非空二叉树，第i层最多有 (2 ^ （i-1）)个节点</p>
</li>
<li>
<p>在高度为h的二叉树上，最多有 2 ^ h - 1 个节点</p>
<ul>
<li>
<p>在任意一棵非空二叉树，如果叶子节点个数为n0，度为2的节点个数为n2，则n0 = n2 + 1；</p>
</li>
<li>
<p>加入度为1的节点总数为n1，则节点总数n = n0 + n1 + n2；</p>
</li>
<li>
<p>二叉树的边数 T = n1 + 2 * n2 = n - 1 = n0 + n1 + n2 - 1;</p>
</li>
<li>
<p>因此 n0 = n2 + 1；</p>
</li>
</ul>
</li>
</ul>
<h3 id="真二叉树proper-binary-tree">真二叉树(Proper Binary Tree)：</h3>
<p>度要么为0，要么为2的二叉树。 如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge7066wg8lj30m40dsmy6.jpg" alt="截屏2020-04-26上午11.20.43"></p>
<p>下图不是真二叉树，因13， 15节点度为1.</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge706cgf5dj30cc0doaan.jpg" alt="截屏2020-04-26上午11.20.47"></p>
<h3 id="满二叉树full-binary-tree">满二叉树(Full Binary Tree)：</h3>
<ul>
<li>最后一层节点的度为0， 其他节点的度都为2</li>
<li>在同样高度的二叉树中，满二叉树的叶子节点最多，总节点数量最多</li>
<li>满二叉树一定是真二叉树，真二叉树不一定是满二叉树</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge708q6326j30qs0bita2.jpg" alt="截屏2020-04-26上午11.24.17"></p>
<p><strong>满二叉树性质</strong></p>
<p>假设满二叉树的高度为h(h &gt;= 1),</p>
<ul>
<li>那么第i层的节点数量为： 2 ^ (i - 1)</li>
<li>叶子节点数量 ：2 ^ (h - 1)</li>
<li>总节点数量： n = 2 ^ h - 1</li>
</ul>
<p>假设满二叉树的节点总数为n，则</p>
<ul>
<li>h = log2(n + 1)</li>
</ul>
<h3 id="完全二叉树">完全二叉树</h3>
<p>对节点从上到下从左至右开始编号，其所有编号都能与相同高度的满二叉树中的编号对应。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge70fvo8zjj316q0f2ac7.jpg" alt="截屏2020-04-26上午11.31.10"></p>
<p><strong>特点</strong></p>
<ul>
<li>叶子节点只能出现在最后两层，最后一层的叶子节点都靠左对齐</li>
<li>完全二叉树丛根节点到倒数第二层是一棵满二叉树</li>
<li>满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</li>
</ul>
<p><strong>性质</strong></p>
<ul>
<li>
<p>度为1的节点只有左子树</p>
</li>
<li>
<p>度为1的节点要么是1个，要么是0个</p>
</li>
<li>
<p>同样节点数量的二叉树，完全二叉树的高度最小</p>
</li>
<li>
<p>假设完全二叉树的高度为h(h &gt;= 1),那么</p>
<ul>
<li>至少有 2 ^ (h - 1) 个节点（最后一层只有一个节点）</li>
<li>最多有 2 ^ h - 1 个节点（满二叉树）</li>
<li>总节点数为n
<ul>
<li>2 ^ (h - 1) &lt;= n &lt; 2 ^ h</li>
<li>h - 1 &lt;= log2N &lt; h</li>
<li>h = floor(log2N) + 1 (floor是向下取整)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>一棵完全二叉树有n个节点，从上到下，从左到右从1开始编号，对任意第i个节点</p>
<ul>
<li>如果i = 1，它是根节点</li>
<li>如果i &gt; 1, 它的父节点的编号为floor(i / 2)</li>
<li>如果 2i &lt;= n, 它的左节点编号为2i</li>
<li>如果 2i &gt; n, 它没有左子节点</li>
<li>如果 2i + 1 &lt;= n , 它的右子节点编号为 2i + 1</li>
<li>如果 2i + 1 &gt; n, 它没有右子节点</li>
</ul>
</li>
<li>
<p>一棵右n个节点的完全二叉树(n &gt; 0)，从上到下，从左到右从0开始编号，对任意第i个节点</p>
<ul>
<li>如果i = 0， 它是根节点</li>
<li>如果i &gt; 0,   它的父节点编号为 floor (i - 1) / 2)</li>
<li>如果2i + 1 &lt;= n - 1, 它的左子节点为 2i + 1</li>
<li>如果2i + 1 &gt; n - 1, 它没有左子节点</li>
<li>如果2i + 2 &lt;= n - 1, 它的右子节点为 2 i + 1</li>
<li>如果2i + 2 &gt; n - 1, 它没有右子节点</li>
</ul>
</li>
</ul>
<h4 id="下图是不是一个完全二叉树">下图是不是一个完全二叉树</h4>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge718vvq4vj30m80hqjsg.jpg" alt="截屏2020-04-26上午11.58.33"></p>
<p>很明显不是， 5 / 6 节点度都是1，都有左子树，故不符合完全二叉树性质。</p>
<h3 id="二叉树的遍历">二叉树的遍历</h3>
<p>遍历是数据结构的常用操作，把所有元素都访问一遍</p>
<p>线性数据结构的遍历比较简单， 正序遍历，倒序遍历。</p>
<p>根据节点访问顺序的不同，二叉树的常见遍历方式由四种：</p>
<ul>
<li>
<p>前序遍历(Preorder Travesal)</p>
</li>
<li>
<p>中序遍历(Inorder Travesal)</p>
</li>
<li>
<p>倒序遍历(Postorder Travesal)</p>
</li>
<li>
<p>层序遍历(Level order Travesal)</p>
</li>
</ul>
<h4 id="前序遍历">前序遍历</h4>
<p>访问顺序：根节点，遍历左子树，遍历右子树</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge737bvnxhj30xm0oy0vu.jpg" alt="截屏2020-04-26下午12.29.13"></p>
<p>打印顺序：7 4 2 1 3 6 9 8 11 10 12</p>
<p>递归 或者利用栈 前序遍历</p>
<h4 id="中序遍历">中序遍历</h4>
<p>访问顺序：中序遍历左子树，再访问根节点，中序遍历右子树</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge73bz21x5j30v80kkwjp.jpg" alt="截屏2020-04-26下午1.11.20"></p>
<p>打印树序：1 2 3 4 5 7 8 9 10 11 12</p>
<p>递归 或者利用栈 中序遍历</p>
<h4 id="后序遍历">后序遍历</h4>
<p>访问顺序：先后续遍历左子树，再后序遍历右子树， 再访问根节点。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge73e6admzj30vi0le79h.jpg" alt="截屏2020-04-26下午1.13.32"></p>
<p>打印顺序：1 3 2 5 4 8 10 12 11 9 7</p>
<p>递归 或者利用栈 后序遍历</p>
<h4 id="层序遍历">层序遍历</h4>
<p>从上到下， 从左到右，依次访问每个节点</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge73gr0xj3j30wc0kkwjx.jpg" alt="截屏2020-04-26下午1.15.37"></p>
<p>打印顺序：7 4 9 2 5 8 11 1 3 10 12</p>
<p>利用队列层序遍历元素。</p>
<h4 id="四则运算">四则运算</h4>
<p>四则运算的表达式可分为三种</p>
<p>前缀表达式（prefix expression）,又称为波兰表达式</p>
<p>中缀表达式（infix epression）</p>
<p>后缀表达式（postfix expression）,又称为逆波兰表达式</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge73r63pfuj311s07c75x.jpg" alt="截屏2020-04-26下午1.25.56"></p>
<h4 id="表达式树">表达式树</h4>
<p>如果将表达式的操作数作为叶子节点， 运算符作为父节点（假设只有四则运算）</p>
<p>这些节点刚好组成一棵树，如表达式： A/B + C * D - E</p>
<h3 id="截屏2020-04-26下午12811httpstva1sinaimgcnlarge007s8zilly1ge73td82tfj30sc0h00vyjpg"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge73td82tfj30sc0h00vy.jpg" alt="截屏2020-04-26下午1.28.11"></h3>
<p>可组成如上一棵树，</p>
<p>对上边的二叉树进行前序遍历，结果如下</p>
<p>-+/AB*CDE  刚好就是波兰表达式即前缀表达式</p>
<p>对上边的二叉树进行中序遍历，结果如下</p>
<p>A/B+C*D-E 刚好是中缀表达式</p>
<p>对上边的二叉树进行后续遍历，结果如下</p>
<p>AB/CD*+E- 刚好就是后缀表达式即逆波兰表达式</p>
<h4 id="根据遍历结果重构二叉树">根据遍历结果，重构二叉树</h4>
<p>以下结果可以重构出一个唯一的二叉树</p>
<p>前序遍历+中序遍历</p>
<p>后序遍历+中序遍历</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge740mv6a0j30jk0c2jse.jpg" alt="截屏2020-04-26下午1.34.47"></p>
<p>前序遍历+后序遍历</p>
<p>如果它是一棵真二叉树，则结果是唯一的。</p>
<p>不然结果不唯一</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge740tducfj30xu06wjsf.jpg" alt="截屏2020-04-26下午1.35.04"></p>
<h3 id="练习题">练习题</h3>
<h4 id="题目一">题目一：</h4>
<blockquote>
<p>如果一棵完全二叉树节点总数是768个，求叶子节点的个数。</p>
</blockquote>
<h5 id="题解">题解：</h5>
<ul>
<li>
<p>假设叶子节点总数为n0，度为1的节点为n1，度为2的节点个数为n2</p>
</li>
<li>
<p>n = n0 + n1 + n2; 且 n0 = n2 + 1(由边数求得);</p>
</li>
<li>
<p>n = no * 2 + n1 - 1;</p>
</li>
<li>
<p>在完全二叉树中， n1要么为0 要么为1</p>
<ul>
<li>当n1为1时，n = 2 * n0, n必然是偶数。 叶子节点个数为 n0 = n / 2. 非叶子节点个数n1 + n2 = n / 2；</li>
<li>当n1为0时，n = 2n0 - 1, n必然是奇数。 叶子节点个数为 n0 = (n + 1) / 2.  非叶子节点个数为 (n - 1) / 2;</li>
</ul>
</li>
<li>
<p>叶子节点个数 n0 = floor((n + 1) / 2) = ceiling(n / 2)</p>
</li>
<li>
<p>非叶子节点个数 n1 + n2 = floor(n / 2) = ceiling((n - 1) / 2)</p>
</li>
<li>
<p>因此叶子节点的个数为 384</p>
</li>
</ul>
<hr>
<h4 id="题目二">题目二：</h4>
<h4 id="226-翻转二叉树httpsleetcode-cncomproblemsinvert-binary-tree"><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4>
<blockquote>
<p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<pre><code> 4
</code></pre>
<p>/  <br>
2     7
/ \   /<br>
1   3 6   9
输出：</p>
<pre><code> 4
</code></pre>
<p>/  <br>
7     2
/ \   /<br>
9   6 3   1
备注:
这个问题是受到 Max Howell 的 原问题 启发的 ：</p>
<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/invert-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>思路：</p>
<p>此题目考查二叉树反转，实际上是考察二叉树遍历，前序，中序，后序遍历都可以拿到节点，把节点的左右子树反转。</p>
<p>前序遍历代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">invertTree</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        TreeNode tmp <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
        root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
        root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> tmp<span style="color:#f92672">;</span>

        invertTree<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
        invertTree<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> root<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>层序遍历代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">invertTree</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        Queue <span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span>queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">();</span>
        queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()){</span>
            TreeNode node <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">poll</span><span style="color:#f92672">();</span>
            TreeNode tmp <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
            node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
            node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> tmp<span style="color:#f92672">;</span>

            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> root<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><hr>
<h4 id="面试题55---i-二叉树的深度httpsleetcode-cncomproblemser-cha-shu-de-shen-du-lcof"><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">面试题55 - I. 二叉树的深度</a></h4>
<blockquote>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<p>3</p>
<p>/<br>
9  20
/ <br>
15   7
返回它的最大深度 3 。</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>思路一：递归</p>
<p>二叉树的最大深度就是根节点的深度，根节点的深度为其左右子节点的最大深度加1， 而其左右子树的最大深度也分别是其子树的最大深度+1， 故想到递归。 代码如下，非常简单。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxDepth</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">return</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>maxDepth<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">),</span>maxDepth<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">))</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>思路二：迭代</p>
<p>类似层序遍历，利用队列，遍历完一层时，height++ 直至结束。 代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxDepth</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">int</span> height <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        Queue<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;();</span>
        queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()){</span>

            <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>size <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">){</span>
                TreeNode node <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">poll</span><span style="color:#f92672">();</span>

                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>

                size <span style="color:#f92672">--;</span>
            <span style="color:#f92672">}</span>

            height <span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> height<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><hr>
<h4 id="222-完全二叉树的节点个数httpsleetcode-cncomproblemscount-complete-tree-nodes"><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4>
<blockquote>
<p>给出一个完全二叉树，求出该树的节点个数。</p>
<p>说明：</p>
<p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p>示例:</p>
<p>输入:
1
/<br>
2   3
/ \  /
4  5 6</p>
<p>输出: 6</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/count-complete-tree-nodes
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>思路一：递归分别计算左右子树的节点个数 再加上1，就是当前树的节点个数。 需要递归每个元素，代码如下，此方法时间复杂度为O（N）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">countNodes</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> countNodes<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> countNodes<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>思路二：以上方法中，适用于任意二叉树，没有用到完全二叉树的特点，效率较差。 故我们在此基础上做一些优化。 heigh方法计算传入node的高度，如果left的高度 == right的高度，则左子树一定是满二叉树，则总节点个数等于左子树个数 + 递归计算右子树节点个数 + 1；</p>
<p>若left的高度 != right的高度， 则右子树一定是满二叉树，则总节点个数等于递归计算左子树个数 + 右子树节点个数 + 1；</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">countNodes1</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">int</span> height_l <span style="color:#f92672">=</span> height<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> height_r <span style="color:#f92672">=</span> height<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>height_l <span style="color:#f92672">==</span> height_r<span style="color:#f92672">){</span>
            <span style="color:#75715e">// 左子树一定是满二叉树
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>1 <span style="color:#f92672">&lt;&lt;</span> height_l<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> countNodes<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 右子树一定是满二叉树
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>1 <span style="color:#f92672">&lt;&lt;</span> height_r<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> countNodes<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">height</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">int</span> height <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        TreeNode node <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>node <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
            height <span style="color:#f92672">++;</span>
            node <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> height<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="二叉树">二叉树</h3>
<h4 id="二叉树的遍历-1">二叉树的遍历</h4>
<p>有两种遍历树的策略：</p>
<ul>
<li>
<p>深度优先搜索(DFS)</p>
<p>在这个策略中，我们采用<strong>深度</strong>作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根到达下一个分支。</p>
<p>深度优先搜索，又可以根据根节点，左子节点和右子节点的相对顺序被分为 <strong>前序遍历</strong> ，<strong>中序遍历</strong>，<strong>后序遍历</strong>。</p>
</li>
<li>
<p>宽度优先搜索(BFS)</p>
<p>我们按照一层一层访问整棵树，高层次的节点将比低层次的节点先访问到。</p>
</li>
</ul>
<p>如下图中，按照1 2 3 4 5比较不同的策略。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geisbs9gpmj30um0dujvl.jpg" alt="image-20200506155730459"></p>
<h4 id="144-二叉树的前序遍历httpsleetcode-cncomproblemsbinary-tree-preorder-traversal"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4>
<blockquote>
<p>给定一个二叉树，返回它的 前序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]<br>
1
<br>
2
/
3</p>
<p>输出: [1,2,3]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h5 id="题解-1">题解：</h5>
<h6 id="思路一">思路一：</h6>
<p>使用递归，先遍历头节点，再左，再右。代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    ArrayList <span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span>list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
    <span style="color:#75715e">// 递归
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">preorderTraversalRecursive</span> <span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
        list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>
        preorderTraversalRecursive<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
        preorderTraversalRecursive<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>

        <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h6 id="思路二">思路二：</h6>
<p>迭代，需要使用额外的栈空间存储结构。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">preorderTransversalRecursive1</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">){</span>
        ArrayList <span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span>list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>

        Stack <span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span>stack <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">();</span>
        stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>

        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>stack<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()){</span>

            TreeNode node <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
            list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>

            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
                stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>

            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
                stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>时间复杂度： O(N)</p>
<p>空间复杂度： O(N)</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geitrbaih9j311y0k4108.jpg" alt="屏幕快照 2020-05-06 下午4.34.52"></p>
<h4 id="94-二叉树的中序遍历httpsleetcode-cncomproblemsbinary-tree-inorder-traversal"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4>
<blockquote>
<p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]
1
<br>
2
/
3</p>
<p>输出: [1,3,2]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h5 id="题解-2">题解：</h5>
<h6 id="思路一-1">思路一：</h6>
<p>递归，代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">inorderTraversalRevursive</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>

        inorderTraversalRevursive<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
        list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>
        inorderTraversalRevursive<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>

        <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h6 id="思路二-1">思路二：</h6>
<p>迭代:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geitsz9ge1j31120jwn4d.jpg" alt="in"></p>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">inorderTraversal</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">){</span>
        ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>

        Stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> stack <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        TreeNode node <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>stack<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">||</span> node <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>

            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>node <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
                stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
                node <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>

            node <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
            list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>
            node <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="145-二叉树的后序遍历httpsleetcode-cncomproblemsbinary-tree-postorder-traversal"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4>
<blockquote>
<p>给定一个二叉树，返回它的 后序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]<br>
1
<br>
2
/
3</p>
<p>输出: [3,2,1]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h5 id="题解-3">题解：</h5>
<h6 id="思路一-2">思路一：</h6>
<p>递归，代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 递归
</span><span style="color:#75715e"></span>    ArrayList <span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">postorderTraversalRecuisive</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
        postorderTraversalRecuisive<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
        postorderTraversalRecuisive<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>

        list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>

        <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h6 id="思路二-2">思路二：</h6>
<p>迭代：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geiu02hbf5j311y0kqagz.jpg" alt="屏幕快照 2020-05-06 下午4.35.19"></p>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 非递归
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">postorderTraversal</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        ArrayList <span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
        Stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> stack <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>

        stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
        TreeNode pre <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>stack<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()){</span>
            TreeNode node <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span><span style="color:#a6e22e">peek</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)||</span> <span style="color:#f92672">(</span>pre <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>pre <span style="color:#f92672">==</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">||</span> pre <span style="color:#f92672">==</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 叶子节点 或者 上一个访问的节点是此节点的子节点时 出栈
</span><span style="color:#75715e"></span>                list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>
                pre <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
                stack<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
                <span style="color:#75715e">// 右子节点不为空
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
                <span style="color:#75715e">// 左子节点不为空
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="102-二叉树的层序遍历httpsleetcode-cncomproblemsbinary-tree-level-order-traversal"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4>
<blockquote>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例：
二叉树：[3,9,20,null,null,15,7],</p>
<p>3
/<br>
9  20
/ <br>
15   7
返回其层次遍历结果：</p>
<p>[
[3],
[9,20],
[15,7]
]</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h5 id="题解-4">题解：</h5>
<p>实现思路，使用队列：</p>
<ol>
<li>将根节点入队</li>
<li>循环执行以下操作，直到队列为空
<ul>
<li>将对头节点A出对，进行访问</li>
<li>将A的左子节点入队</li>
<li>将A的右子节点入队</li>
</ul>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geiudzhnwkj31200k0doc.jpg" alt="level"></p>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;&gt;</span> <span style="color:#a6e22e">levelOrder</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">){</span>
        ArrayList list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">();</span>
        
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
        Queue<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;();</span>
        queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
        
        TreeNode node <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()){</span>
            ArrayList a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">();</span>
            <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>count <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">){</span>
                node <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">();</span>
                
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
                
                a<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>
                count <span style="color:#f92672">--;</span>
            <span style="color:#f92672">}</span>
            
            list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        
        <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="104-二叉树的最大深度httpsleetcode-cncomproblemsmaximum-depth-of-binary-tree"><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4>
<h5 id="题解-5">题解：</h5>
<h6 id="思路一-3">思路一：</h6>
<p>使用递归， node节点的高度等于其 max(node.left, node.right) + 1 左右孩子的高度中的较大者 + 1. 代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxDepth</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
        
        <span style="color:#66d9ef">return</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>maxDepth<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">),</span>maxDepth<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">))</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h6 id="思路二-3">思路二：</h6>
<p>迭代， 类似层序遍历，当一层遍历完时，height ++ . 直到遍历完所有节点</p>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxDepth</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>

        Queue <span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;();</span>
        queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
        TreeNode node <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">int</span> height <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()){</span>
            <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>size <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">){</span>

                node <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">();</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>

                size <span style="color:#f92672">--;</span>
            <span style="color:#f92672">}</span>

            height <span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> height<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="662-二叉树最大宽度httpsleetcode-cncomproblemsmaximum-width-of-binary-tree"><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h4>
<blockquote>
<p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p>
<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p>
<p>示例 1:</p>
<p>输入:</p>
<pre><code>    1
  /   \
 3     2
/ \     \  
</code></pre>
<p>5   3     9</p>
<p>输出: 4
解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。
示例 2:</p>
<p>输入:</p>
<pre><code>   1
  /  
 3    
/ \       
</code></pre>
<p>5   3</p>
<p>输出: 2
解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。
示例 3:</p>
<p>输入:</p>
<pre><code>   1
  / \
 3   2 
/        
</code></pre>
<p>5</p>
<p>输出: 2
解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。
示例 4:</p>
<p>输入:</p>
<pre><code>   1
  / \
 3   2
/     \  
</code></pre>
<p>5       9
/        <br>
6           7
输出: 8
解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。
注意: 答案在32位有符号整数的表示范围内。</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h5 id="题解-6">题解：</h5>
<p>层序遍历，计算每一层的宽度，各层中宽度的最大值就是最终结果。 每一层的宽度我们需要每层元素的下标。下标存入链表中，如果有左子树，其左子树的下标为index * 2. 右子树的下标为index * 2 + 1.</p>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">widthOfBinaryTree</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>

        Queue<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;();</span>
        LinkedList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;();</span>

        queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
        list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> maxWidth <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()){</span>
            <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>
            maxWidth <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>size<span style="color:#f92672">,</span>maxWidth<span style="color:#f92672">);</span>

            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>size <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">){</span>
                TreeNode node <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">();</span>
                Integer curIdx <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">removeFirst</span><span style="color:#f92672">();</span>

                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
                    queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
                    list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>curIdx <span style="color:#f92672">*</span> 2<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
                    list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>curIdx <span style="color:#f92672">*</span> 2 <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>

                size <span style="color:#f92672">--;</span>
            <span style="color:#f92672">}</span>

            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">&gt;=</span> 2<span style="color:#f92672">){</span>
                maxWidth <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>maxWidth<span style="color:#f92672">,</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">getLast</span><span style="color:#f92672">()</span> <span style="color:#f92672">-</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">getFirst</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> maxWidth<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="589-n叉树的前序遍历httpsleetcode-cncomproblemsn-ary-tree-preorder-traversal"><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N叉树的前序遍历</a></h4>
<h5 id="题解-7">题解：</h5>
<h6 id="思路一-4">思路一：</h6>
<p>递归</p>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">ArrayList list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">();</span>
<span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">preorder</span><span style="color:#f92672">(</span>Node root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
    
    Node node <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>
    list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>

    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++){</span>
        
        preorder<span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h6 id="思路二-4">思路二：</h6>
<p>迭代 , 跟二叉树前序遍历相同.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">preorder</span><span style="color:#f92672">(</span>Node root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>

    Stack<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> stack <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
    stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>stack<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()){</span>

        Node node <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
        list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
            stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">));</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="590-n叉树的后序遍历httpsleetcode-cncomproblemsn-ary-tree-postorder-traversal"><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N叉树的后序遍历</a></h4>
<blockquote>
<p>给定一个 N 叉树，返回其节点值的后序遍历。</p>
<p>例如，给定一个 3叉树 :</p>
<p>返回其后序遍历: [5,6,3,2,4,1].</p>
<p>说明: 递归法很简单，你可以使用迭代法完成此题吗?</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h5 id="题解-8">题解：</h5>
<h6 id="思路一-5">思路一：</h6>
<p>递归，先遍历头节点，然后循环依次递归遍历头节点的子节点。代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    ArrayList list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">postorder</span><span style="color:#f92672">(</span>Node root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>

        Node node <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            Node n <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
            postorder<span style="color:#f92672">(</span>n<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>

        <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>思路二：</p>
<p>迭代， 跟二叉树的后序遍历迭代法，逻辑一致。</p>
<ul>
<li>将root入栈</li>
<li>循环执行以下操纵，直到栈为空
<ul>
<li>如果栈顶元素是叶子节点，或者上一次访问的节点是当前节点的子节点时，则栈顶元素出栈访问</li>
<li>否则，将栈顶元素的children从大到小依次入栈。</li>
</ul>
</li>
</ul>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 迭代
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">postorder</span><span style="color:#f92672">(</span>Node root<span style="color:#f92672">){</span>
        ArrayList list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>

        Stack<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> stack <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
        Node pre <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>stack<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()){</span>
            Node node <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span><span style="color:#a6e22e">peek</span><span style="color:#f92672">();</span>

            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>pre<span style="color:#f92672">)){</span>
                <span style="color:#75715e">// 如果是叶子节点 或者 上一次访问的节点是此节点的子节点时  出栈访问
</span><span style="color:#75715e"></span>                list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>

                pre <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
                stack<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
                    stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">));</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="559-n叉树的最大深度httpsleetcode-cncomproblemsmaximum-depth-of-n-ary-tree"><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N叉树的最大深度</a></h4>
<h5 id="题解-9">题解：</h5>
<h6 id="思路一-6">思路一：</h6>
<p>递归，非常容易想的思路，父节点的深度，等于其子节点中最大深度再加一。 代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxDepth</span><span style="color:#f92672">(</span>Node root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
        
        <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            max <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>max<span style="color:#f92672">,</span>maxDepth<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">))</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> max<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h6 id="思路二-5">思路二：</h6>
<p>迭代，利用树的层序遍历，遍历完一层时，高度+1, 直到遍历完整棵树。代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 迭代 层序遍历
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxDepth</span><span style="color:#f92672">(</span>Node root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>

        Queue<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;();</span>
        queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
        Node node <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">int</span> height <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()){</span>
            <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>

            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>size <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">){</span>
                node <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">();</span>

                <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                    queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">));</span>
                <span style="color:#f92672">}</span>

                size <span style="color:#f92672">--;</span>
            <span style="color:#f92672">}</span>

            height <span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> height<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="114-二叉树展开为链表httpsleetcode-cncomproblemsflatten-binary-tree-to-linked-list"><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4>
<h5 id="题解-10">题解：</h5>
<p>思路一：</p>
<p>迭代, 可以发现展开的顺序其实就是二叉树前序遍历。</p>
<ol>
<li>将左子树插入到右子树</li>
<li>将原来的右子树插入到左子树最右边节点</li>
<li>考虑新的右子树的根节点，重复上边的过程</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    1
   <span style="color:#f92672">/</span> <span style="color:#960050;background-color:#1e0010">\</span>
  2   5
 <span style="color:#f92672">/</span> <span style="color:#960050;background-color:#1e0010">\</span>   <span style="color:#960050;background-color:#1e0010">\</span>
3   4   6

<span style="color:#75715e">//将 1 的左子树插入到右子树的地方
</span><span style="color:#75715e"></span>    1
     <span style="color:#960050;background-color:#1e0010">\</span>
      2         5
     <span style="color:#f92672">/</span> <span style="color:#960050;background-color:#1e0010">\</span>         <span style="color:#960050;background-color:#1e0010">\</span>
    3   4         6        
<span style="color:#75715e">//将原来的右子树接到左子树的最右边节点
</span><span style="color:#75715e"></span>    1
     <span style="color:#960050;background-color:#1e0010">\</span>
      2          
     <span style="color:#f92672">/</span> <span style="color:#960050;background-color:#1e0010">\</span>          
    3   4  
         <span style="color:#960050;background-color:#1e0010">\</span>
          5
           <span style="color:#960050;background-color:#1e0010">\</span>
            6
            
 <span style="color:#75715e">//将 2 的左子树插入到右子树的地方
</span><span style="color:#75715e"></span>    1
     <span style="color:#960050;background-color:#1e0010">\</span>
      2          
       <span style="color:#960050;background-color:#1e0010">\</span>          
        3       4  
                 <span style="color:#960050;background-color:#1e0010">\</span>
                  5
                   <span style="color:#960050;background-color:#1e0010">\</span>
                    6   
        
 <span style="color:#75715e">//将原来的右子树接到左子树的最右边节点
</span><span style="color:#75715e"></span>    1
     <span style="color:#960050;background-color:#1e0010">\</span>
      2          
       <span style="color:#960050;background-color:#1e0010">\</span>          
        3      
         <span style="color:#960050;background-color:#1e0010">\</span>
          4  
           <span style="color:#960050;background-color:#1e0010">\</span>
            5
             <span style="color:#960050;background-color:#1e0010">\</span>
              6         
  

</code></pre></div><p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 第一步：将左子树 插入到右子树上
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 第二步：将之前的右子树 插入到之前左子树的最右边节点
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 第三部：考虑新的右子树的根节点，重复上边的过程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flattern</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">){</span>

        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
                <span style="color:#75715e">// 如果没有左子树，直接处理其右子树
</span><span style="color:#75715e"></span>                root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>

            <span style="color:#75715e">// 将原来右子树保存一份
</span><span style="color:#75715e"></span>            TreeNode tmp <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
            
            <span style="color:#75715e">// 把左子树 插入 到右子树的位置
</span><span style="color:#75715e"></span>            root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
            
            <span style="color:#75715e">// 清空原来左子树
</span><span style="color:#75715e"></span>            root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

            <span style="color:#75715e">// 找到原来 左子树的最右边节点
</span><span style="color:#75715e"></span>            TreeNode pre <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>pre<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
                pre <span style="color:#f92672">=</span> pre<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>

            <span style="color:#75715e">// 原来的右子树 插入到 原来左子树的最右边
</span><span style="color:#75715e"></span>            pre<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> tmp<span style="color:#f92672">;</span>

            root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h6 id="思路二-6">思路二：</h6>
<p>递归：  其实跟上述做法思路类似</p>
<ol>
<li>分别将左子树 和 右子树变为链表</li>
<li>把左子树插入到右子树的位置，</li>
<li>将原来右子树插入到原来左子树的最右边</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">   <span style="color:#75715e">// 递归
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 第一步 左子树变为链表
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 第二步 右子树变为链表
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 第三步 原来的左子树 插入到右子树的位置
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 第四步 清空原来的左子树
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 第五步 把原来的右子树 插入到原来左子树的最右边
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flatten</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>

        <span style="color:#75715e">// 左子树变为链表
</span><span style="color:#75715e"></span>        flatten<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
        <span style="color:#75715e">// 右子树变为链表
</span><span style="color:#75715e"></span>        flatten<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>

        <span style="color:#75715e">// 保存原来的右子树
</span><span style="color:#75715e"></span>        TreeNode tmp <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 左子树插入到右子树位置
</span><span style="color:#75715e"></span>        root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 清空左子树
</span><span style="color:#75715e"></span>        root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        <span style="color:#75715e">// 找到左子树的最右边
</span><span style="color:#75715e"></span>        TreeNode pre <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>pre<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
            pre <span style="color:#f92672">=</span> pre<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        
        <span style="color:#75715e">// 原来的右子树 插入到左子树的最右边
</span><span style="color:#75715e"></span>        pre<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> tmp<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

</code></pre></div><h4 id="106-从中序与后序遍历序列构造二叉树httpsleetcode-cncomproblemsconstruct-binary-tree-from-inorder-and-postorder-traversal"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4>
<blockquote>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:
你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
返回如下的二叉树：</p>
<p>3</p>
<p>/	<br>
9  	20
/    \</p>
<p>15   7</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h5 id="题解-11">题解：</h5>
<p><strong>如何根据两种遍历序列构造数:  中序，和前序 / 后序等等</strong></p>
<ul>
<li>通常从前序遍历或者后序遍历开始，根据不同遍历方法的规律，选择合适的节点构造树
<ul>
<li>比如，前序遍历的第一个节点就是根节点，然后是它的左子节点，右子节点。</li>
<li>后序遍历的最后一个节点是根节点，然后是它的右子节点，左子节点。</li>
</ul>
</li>
<li>从先序 / 后序序列中找到根节点，根据根节点将中序序列分为左子树，右子树。 从中序序列中获得的信息是： 如果当前子树为空 (返回 None), 否则继续构造子树。</li>
</ul>
<h6 id="算法步骤">算法步骤：</h6>
<ol>
<li>创建map用来存放中序遍历的值和下标。</li>
<li>rootIdx 用来存放后序遍历数组中，创建root节点的下标</li>
<li>将后序遍历数组全局化</li>
<li>后序遍历的最后一个元素是根节点，先拿到根节点，在上述map中查找在中序遍历中的index, 因为中序遍历顺序为 <strong>左 中 右</strong>。 所以左子树为[0, index - 1], 右子树为[index + 1, end]。</li>
<li>递归构造根节点的 右子树 和 左子树。 这里要注意，一定是先构造右子树。 因为后序遍历的顺序为  <strong>左 右 中</strong>  ，所以出去最后一个元素后，最后一个元素为右子树的根节点</li>
<li>依次构建，直到没有元素。</li>
</ol>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// map中存放中序遍历的节点和索引值
</span><span style="color:#75715e"></span>    HashMap<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span>Integer<span style="color:#f92672">&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span>
    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> postorder <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> rootIdx <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">buildTree</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> inorder<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> postorder<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>inorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> postorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> inorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">!=</span> postorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>inorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 1<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">(</span>inorder<span style="color:#f92672">[</span>0<span style="color:#f92672">]);</span>

        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">postorder</span> <span style="color:#f92672">=</span> postorder<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">rootIdx</span> <span style="color:#f92672">=</span> postorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 将中序遍历的节点和索引值存入数组
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> inorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>inorder<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span>i<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> buildTreeHelper<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span>inorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>


    <span style="color:#66d9ef">private</span> TreeNode <span style="color:#a6e22e">buildTreeHelper</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> is<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> ie<span style="color:#f92672">){</span>

        <span style="color:#75715e">// 左边索引 &gt; 右边索引 -&gt; 没有元素
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>is <span style="color:#f92672">&gt;</span> ie<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        <span style="color:#75715e">// 后序遍历最后一位是根节点，或者根节点的索引
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>postorder<span style="color:#f92672">[</span>rootIdx<span style="color:#f92672">]);</span>

        <span style="color:#75715e">// 根节点
</span><span style="color:#75715e"></span>        TreeNode node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">(</span>postorder<span style="color:#f92672">[</span>rootIdx<span style="color:#f92672">]);</span>

        rootIdx <span style="color:#f92672">--;</span>
        <span style="color:#75715e">// 右子树 ：  【idx + 1, inorder.length - 1】
</span><span style="color:#75715e"></span>        node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> buildTreeHelper<span style="color:#f92672">(</span>idx <span style="color:#f92672">+</span> 1<span style="color:#f92672">,</span> ie<span style="color:#f92672">);</span>
        <span style="color:#75715e">// 左子树 ：  【0 ， idx-1】
</span><span style="color:#75715e"></span>        node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> buildTreeHelper<span style="color:#f92672">(</span>is<span style="color:#f92672">,</span>idx <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>

        <span style="color:#66d9ef">return</span> node<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h5 id="复杂度分析">复杂度分析：</h5>
<p>时间复杂度： O(N), 递归N次，其中N为节点个数</p>
<p>空间复杂度：O(N), 使用递归，需要额外的栈空间，由于栈的深度为N，故空间复杂度为 O(N).</p>
<h4 id="105-从前序与中序遍历序列构造二叉树httpsleetcode-cncomproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4>
<blockquote>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:
你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：</p>
<p>3
/<br>
9  20
/ <br>
15   7</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h5 id="题解-12">题解：</h5>
<p>此题跟上一道题，根据后序遍历和中序遍历构造二叉树思路基本一致。</p>
<ul>
<li>存储中序遍历的节点 和 下标对应的map</li>
<li>前序遍历首元素为二叉树的根节点，找到根节点，在map中找到下标</li>
<li>中序遍历遍历顺序为 <strong>根节点 左 右</strong> , 所以根节点的左子树为[0, idx - 1]. 右子树为[idx + 1,end].</li>
<li>分别构建左右子树</li>
</ul>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">HashMap<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span>Integer<span style="color:#f92672">&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span> <span style="color:#75715e">// 用于存放中序遍历的 元素 -&gt; 下标对应的字典
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> rootIdx <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>                                <span style="color:#75715e">// 存放前序遍历的数组中，root的下标
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> preorder <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>                          <span style="color:#75715e">// 全局化 前序遍历数组
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">private</span> TreeNode <span style="color:#a6e22e">buildTreeHelper</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> startIdx<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> endIdx<span style="color:#f92672">){</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>startIdx <span style="color:#f92672">&gt;</span> endIdx<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

    TreeNode root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">(</span>preorder<span style="color:#f92672">[</span>rootIdx<span style="color:#f92672">]);</span>
    <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>preorder<span style="color:#f92672">[</span>rootIdx<span style="color:#f92672">]);</span>

    rootIdx <span style="color:#f92672">++;</span>

    <span style="color:#75715e">// 左子树
</span><span style="color:#75715e"></span>    root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> buildTreeHelper<span style="color:#f92672">(</span>startIdx<span style="color:#f92672">,</span>idx <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>

    <span style="color:#75715e">// 右子树
</span><span style="color:#75715e"></span>    root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> buildTreeHelper<span style="color:#f92672">(</span>idx <span style="color:#f92672">+</span> 1<span style="color:#f92672">,</span> endIdx<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">return</span> root<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">buildTree</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> preorder<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> inorder<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>inorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> preorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> inorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">!=</span> preorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>inorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 1<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">(</span>inorder<span style="color:#f92672">[</span>0<span style="color:#f92672">]);</span>

    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> inorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>inorder<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span>i<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">preorder</span> <span style="color:#f92672">=</span> preorder<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">return</span> buildTreeHelper<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span>preorder<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h5 id="复杂度分析-1">复杂度分析：</h5>
<p>时间复杂度： O(N), 递归N次，其中N为节点个数</p>
<p>空间复杂度：O(N), 使用递归，需要额外的栈空间，由于栈的深度为N，故空间复杂度为 O(N).</p>
<h4 id="面试题-1712-binodehttpsleetcode-cncomproblemsbinode-lcci"><a href="https://leetcode-cn.com/problems/binode-lcci/">面试题 17.12. BiNode</a></h4>
<blockquote>
<p>二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求值的顺序保持不变，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>
<p>返回转换后的单向链表的头节点。</p>
<p>注意：本题相对原题稍作改动</p>
<p>示例：</p>
<p>输入： [4,2,5,1,3,null,6,0]
输出： [0,null,1,null,2,null,3,null,4,null,5,null,6]</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binode-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h5 id="题解-13">题解：</h5>
<p>二叉树转为链表后，仍然为有序，很容易想到中序遍历，二叉搜索树中序遍历转链表后， 依然是有序的。</p>
<h6 id="思路一-7">思路一：</h6>
<p>中序遍历二叉树，将节点按顺序保存至List数组中，初始化虚拟头节点，依次拼接List数组中的节点。</p>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 二叉树中序遍历
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 创建一个List存放各个节点， 再串起来称为新的单向链表
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">){</span>

        List<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>

        Stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> stack <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>stack<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">||</span> root <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
                stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>

                root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>

            root <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
            list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>

            root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
            root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> list<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">convertBiNode1</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        List<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> dfs<span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>

        TreeNode head <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">(-</span>1<span style="color:#f92672">);</span>
        TreeNode node <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
            node <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>然而在题目中，要求原地算法，在原始的二叉搜索树上直接操作，接下来，我们尝试在原始的二叉搜索树上修改。</p>
<h6 id="思路二-7">思路二：</h6>
<p>中序遍历，迭代</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">convertBiNode2</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        TreeNode head <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">(-</span>1<span style="color:#f92672">);</span>
        TreeNode tmp <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>

        Stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> stack <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>stack<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">||</span> root <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
                stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>

                root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>

            root <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>

            tmp<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>
            tmp <span style="color:#f92672">=</span> tmp<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>

            root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
            root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

</code></pre></div><h6 id="思路三">思路三：</h6>
<p>中序遍历 递归</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">convertBiNode</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        TreeNode head <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">(-</span>1<span style="color:#f92672">);</span>
        TreeNode tmp <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>

        convertBiNode<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>

        tmp<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>
        tmp <span style="color:#f92672">=</span> tmp<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>

        root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        convertBiNode<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">飞熊</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2020-04-26
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://zhangxiongfeiv.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
          <a href="https://zhangxiongfeiv.github.io/tags/bfs/">BFS</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/hello%E5%BC%A0%E6%B8%85%E5%A6%8D/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">Hello,张清妍</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/%E9%98%9F%E5%88%97%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">
            <span class="next-text nav-default">队列刷题记录</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="310311589@qq.com" rel="me noopener" class="iconfont"
      title="email"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/zhangxiongfeiv" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://zhangxiongfeiv.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        飞熊
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
