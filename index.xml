<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>API调用工程师的进阶</title>
    <link>https://zhxiongfei.github.io/</link>
    <description>Recent content on API调用工程师的进阶</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 29 Dec 2018 20:24:28 +0800</lastBuildDate>
    
	<atom:link href="https://zhxiongfei.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode刷题回顾与总结</title>
      <link>https://zhxiongfei.github.io/post/leetcode%E5%88%B7%E9%A2%98%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 28 May 2020 10:09:44 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/leetcode%E5%88%B7%E9%A2%98%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/</guid>
      <description>LeetCode刷题回顾与总结 2020.5.27记 截止 5.27日，leetcode总刷题数到达200，写一篇文章以回顾，总结。 起因 非计算机专</description>
    </item>
    
    <item>
      <title>利用RunLoop控制线程生命周期</title>
      <link>https://zhxiongfei.github.io/post/%E5%88%A9%E7%94%A8runloop%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Mon, 02 Nov 2020 11:54:29 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%88%A9%E7%94%A8runloop%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>利用RunLoop控制线程生命周期 需求 子线程频繁的做任务，此时如果每次做任务时创建子线程，任务完成销毁子线程，频繁得创建销毁线程对系统的开销</description>
    </item>
    
    <item>
      <title>IP地址,MAC地址,计算机连接方式</title>
      <link>https://zhxiongfei.github.io/post/ip%E5%9C%B0%E5%9D%80mac%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 22 Oct 2020 11:54:29 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/ip%E5%9C%B0%E5%9D%80mac%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</guid>
      <description>IP地址,MAC地址,计算机连接方式 计算机之间的通信基础 需要得知对方的 IP地址 最终是根据MAC地址(网卡地址),输送数据到网卡，被网卡接收 如</description>
    </item>
    
    <item>
      <title>网络的一些基本概念</title>
      <link>https://zhxiongfei.github.io/post/%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Wed, 14 Oct 2020 11:54:29 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description>网络的一些基本概念 因特网 : 全世界最大的互联网 将全世界所有的计算机连接在一起 一般使用大写I开头的Internet特指因特网 ISP Internet Service Provider, Intern</description>
    </item>
    
    <item>
      <title>回溯算法总结</title>
      <link>https://zhxiongfei.github.io/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 22 Sep 2020 11:54:29 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>(转)回溯算法入门级详解 + 练习 (查看原文) 回溯算法与深度优先遍历 以下是维基百科中 回溯算法 和 深度优先遍历 的定义。 回溯法 回溯法采用试错的思想，它</description>
    </item>
    
    <item>
      <title>为什么iOS App可以响应事件？- RunLoop</title>
      <link>https://zhxiongfei.github.io/post/%E4%B8%BA%E4%BB%80%E4%B9%88ios-app%E8%83%BD%E4%B8%80%E7%9B%B4%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6-runloop/</link>
      <pubDate>Wed, 16 Sep 2020 22:25:46 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%B8%BA%E4%BB%80%E4%B9%88ios-app%E8%83%BD%E4%B8%80%E7%9B%B4%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6-runloop/</guid>
      <description>为什么iOS App可以响应事件？- RunLoop 什么是RunLoop？ 顾名思义 运行循环 在程序运行过程中循环做一些事情 应用范畴 定时器(Timer), PerformSelector GCD Async</description>
    </item>
    
    <item>
      <title>网络分层</title>
      <link>https://zhxiongfei.github.io/post/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/</link>
      <pubDate>Sun, 06 Sep 2020 22:25:46 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/</guid>
      <description>网络分层 网络互连模型 为了更好的促进互联网的研究和发展，国际标准组织 ISO 在1985年制定了网络互连模型 OSI (Open System Interconnect Reference Model), 具有7层结构 应用层 协议 : FTP,HTTP,SMTP,DNS,DHCP 报文</description>
    </item>
    
    <item>
      <title>Advanced Memory Management Programming Guide</title>
      <link>https://zhxiongfei.github.io/post/advanced-memory-management-programming-guide/</link>
      <pubDate>Fri, 14 Aug 2020 11:54:29 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/advanced-memory-management-programming-guide/</guid>
      <description>Advanced Memory Management Programming Guide (高级内存管理编程指南) 原文地址 Application memory management is the process of allocating memory during your program’s runtime, using it, and freeing it when you are done with it. A well-written program uses as little memory as possible. In Objective-C, it can also be seen as</description>
    </item>
    
    <item>
      <title>PointInside:withEvent:</title>
      <link>https://zhxiongfei.github.io/post/pointinside-withevent/</link>
      <pubDate>Tue, 21 Jul 2020 17:32:04 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/pointinside-withevent/</guid>
      <description>pointInside:withEvent: 苹果官方文档原文地址 Returns a Boolean value indicating whether the receiver contains the specified point. 返回一个布尔值, 表示接收方是否包含指定点. Declaration 1 - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event; Parameters point A point that is in the receiver’s local coordinate</description>
    </item>
    
    <item>
      <title>HitTest:withEvent:</title>
      <link>https://zhxiongfei.github.io/post/hittest-withevent/</link>
      <pubDate>Tue, 21 Jul 2020 17:06:53 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/hittest-withevent/</guid>
      <description>hitTest:withEvent: 苹果官方文档原文地址 : hitTest:withEvent: Returns the farthest descendant of the receiver in the view hierarchy (including itself) that contains a specified point. 返回包含指定点的视图层次结构中接收者的最远后代 (包括自身). Declaration 1 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event; Parameters point</description>
    </item>
    
    <item>
      <title>Using Responders and the Responder Chain to Handle Events</title>
      <link>https://zhxiongfei.github.io/post/using-responders-and-the-responder-chain-to-handle-events/</link>
      <pubDate>Tue, 21 Jul 2020 11:52:08 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/using-responders-and-the-responder-chain-to-handle-events/</guid>
      <description>Using Responders and the Responder Chain to Handle Events 原文地址 : Using Responders and the Responder Chain to Handle Events 使用响应者和响应链来处理事件 Learn how to handle events that propagate through your app. 了解如何处理应用事件的传递. Overview Apps receive and handle events using responder objects.</description>
    </item>
    
    <item>
      <title>原型模式,深拷贝,浅拷贝</title>
      <link>https://zhxiongfei.github.io/post/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Tue, 14 Jul 2020 11:54:29 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</guid>
      <description>原型模式 本文概念主要摘取书籍**《大话设计模式》**, ObjC的深浅拷贝主要是对**《苹果开发文档 》**相关内容的理解和翻译，以及写代码进行</description>
    </item>
    
    <item>
      <title>装饰器模式与ObjC的Category</title>
      <link>https://zhxiongfei.github.io/post/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8Eobjc%E7%9A%84category/</link>
      <pubDate>Mon, 13 Jul 2020 14:17:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8Eobjc%E7%9A%84category/</guid>
      <description>装饰器模式 装饰器模式(Decorator Pattern) 允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现</description>
    </item>
    
    <item>
      <title>团灭买卖股票问题</title>
      <link>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 10 Jul 2020 13:01:07 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</guid>
      <description>121. 买卖股票的最佳时机 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一</description>
    </item>
    
    <item>
      <title>享元模式与UITableViewCell复用机制</title>
      <link>https://zhxiongfei.github.io/post/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B8%8Euitableviewcell%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 08 Jul 2020 12:50:06 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B8%8Euitableviewcell%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/</guid>
      <description>享元模式(Flyweight) 概念 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型</description>
    </item>
    
    <item>
      <title>函数指针,block与lambda表达式</title>
      <link>https://zhxiongfei.github.io/post/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88block%E4%B8%8Elambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 07 Jul 2020 00:56:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88block%E4%B8%8Elambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>C语言中的函数指针, OjbC中的block,以及C++和Java中的lambda表达式非常类似. 在学习单个语言时不会想到他们之间的共通点和区</description>
    </item>
    
    <item>
      <title>ObjC中全局变量和@property属性的区别</title>
      <link>https://zhxiongfei.github.io/post/objc%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8Cproperty%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 06 Jul 2020 23:47:38 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/objc%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8Cproperty%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description></description>
    </item>
    
    <item>
      <title>一道有意思的考察block的面试题</title>
      <link>https://zhxiongfei.github.io/post/%E4%B8%80%E9%81%93%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E8%80%83%E5%AF%9Fblock%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 06 Jul 2020 22:25:46 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%B8%80%E9%81%93%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E8%80%83%E5%AF%9Fblock%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>有趣的面试经历 记得是 2018年底，去海淀区一家公司面试。 记得约的下午2点钟的面试，差不多中午那会就到达了即将面试的公司附近。 距离2点钟还早，</description>
    </item>
    
    <item>
      <title>模拟OjbC中抽象类的使用</title>
      <link>https://zhxiongfei.github.io/post/%E6%A8%A1%E6%8B%9Fojbc%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 04 Jul 2020 17:57:39 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E6%A8%A1%E6%8B%9Fojbc%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>抽象类 什么是抽象类? 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够</description>
    </item>
    
    <item>
      <title>设计模式之抽象工厂模式</title>
      <link>https://zhxiongfei.github.io/post/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 04 Jul 2020 14:46:20 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 暂且不提工厂模式， 我们先了解一个简单的需求, 然后通过这个需求的改进过程了解工厂模式。 需求如下 : 假设现在，我有一辆车Car，它有一个 go() 方法</description>
    </item>
    
    <item>
      <title>约瑟夫环的几种解决方法</title>
      <link>https://zhxiongfei.github.io/post/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 03 Jul 2020 14:48:59 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>约瑟夫问题 本文参考 leetcode大神题解，查看原文 首先我们来了解下，什么是约瑟夫问题？ 这个问题是以弗拉维奥·约瑟夫命名的，他是1世纪的一名</description>
    </item>
    
    <item>
      <title>通过优化排序了解策略模式</title>
      <link>https://zhxiongfei.github.io/post/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%9C%A8ios%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Thu, 02 Jul 2020 17:10:23 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%9C%A8ios%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>什么是策略模式? 接下来，我们通过之前复习过的排序算法 来谈谈策略模式。 以选择排序为例，之前我们写的排序算法， 数据类型写的 Integer 类型的数组. 代码如下</description>
    </item>
    
    <item>
      <title>了解最长重复子串和子序列</title>
      <link>https://zhxiongfei.github.io/post/%E4%BA%86%E8%A7%A3%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Wed, 01 Jul 2020 17:01:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%BA%86%E8%A7%A3%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>子序列 和 子串(子数组) Q:首先这两个看起来很像的概念有什么区别呢？ A: 先抛出结论，子序列默认不连续， 子串(子数组)默认连续 接下来，通过两道题，</description>
    </item>
    
    <item>
      <title>143.重排链表</title>
      <link>https://zhxiongfei.github.io/post/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 30 Jun 2020 13:31:08 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</guid>
      <description>143. 重排链表 给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯</description>
    </item>
    
    <item>
      <title>215.数组的第K个最大元素</title>
      <link>https://zhxiongfei.github.io/post/215.%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Mon, 29 Jun 2020 13:31:39 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/215.%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>215. 数组中的第K个最大元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例</description>
    </item>
    
    <item>
      <title>153.寻找旋转排序数组中的最小值</title>
      <link>https://zhxiongfei.github.io/post/153.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</link>
      <pubDate>Sun, 28 Jun 2020 20:25:16 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/153.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</guid>
      <description>153. 寻找旋转排序数组中的最小值 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假</description>
    </item>
    
    <item>
      <title>238.除自身以外数组的乘积</title>
      <link>https://zhxiongfei.github.io/post/238.-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</link>
      <pubDate>Sun, 28 Jun 2020 18:34:12 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/238.-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</guid>
      <description>238. 除自身以外数组的乘积 给你一个长度为 n 的整数数组 nums，其中 n &amp;gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 输入: [1,2,3,4]</description>
    </item>
    
    <item>
      <title>iOS中内联函数的使用</title>
      <link>https://zhxiongfei.github.io/post/ios%E4%B8%AD%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 28 Jun 2020 14:03:20 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/ios%E4%B8%AD%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>内联函数(inline function) inline 使用 inline 修饰函数的声明或者实现，可以使其变为联函数 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函</description>
    </item>
    
    <item>
      <title>剑指.Offer.31.栈的压入</title>
      <link>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87.offer.31.%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5.%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sun, 28 Jun 2020 09:57:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87.offer.31.%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5.%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</guid>
      <description>剑指 Offer 31. 栈的压入、弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。</description>
    </item>
    
    <item>
      <title>剑指offer.04.二维数组中查找</title>
      <link>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sat, 27 Jun 2020 17:26:16 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE/</guid>
      <description>剑指 Offer 04. 二维数组中的查找 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输</description>
    </item>
    
    <item>
      <title>二分应用之剑指Offer53在排序数组中查找数字I</title>
      <link>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%88%86%E5%BA%94%E7%94%A8%E4%B9%8B%E5%89%91%E6%8C%87offer53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97i/</link>
      <pubDate>Thu, 25 Jun 2020 22:37:19 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%88%86%E5%BA%94%E7%94%A8%E4%B9%8B%E5%89%91%E6%8C%87offer53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97i/</guid>
      <description>剑指 Offer 53 - I. 在排序数组中查找数字 I 统计一个数字在排序数组中出现的次数。 示例 1: 输入: nums = [5,7,7,8,8,10], target = 8 输出: 2 示例 2: 输入: nums = [5,7,7,8,8,10], target = 6 输出: 0 限制：</description>
    </item>
    
    <item>
      <title>139.单词拆分</title>
      <link>https://zhxiongfei.github.io/post/139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</link>
      <pubDate>Thu, 25 Jun 2020 10:35:24 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</guid>
      <description>139. 单词拆分 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆</description>
    </item>
    
    <item>
      <title>数组代替HashMap提高效率的应用</title>
      <link>https://zhxiongfei.github.io/post/%E6%95%B0%E7%BB%84%E4%BB%A3%E6%9B%BFhashmap%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Wed, 24 Jun 2020 16:48:53 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E6%95%B0%E7%BB%84%E4%BB%A3%E6%9B%BFhashmap%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>首先，我们看一道题目，用此题目为例说明，使用数组代替哈希表的使用 剑指 Offer 50. 第一个只出现一次的字符 在字符串 s 中找出第一个只出现一次的字符。如果没</description>
    </item>
    
    <item>
      <title>分治之快速幂算法</title>
      <link>https://zhxiongfei.github.io/post/%E5%88%86%E6%B2%BB%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 24 Jun 2020 15:04:47 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%88%86%E6%B2%BB%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/</guid>
      <description>快速幂算法 快速幂（Exponentiation by squaring，平方求幂）是一种简单而有效的小算法，它可以以**O(log N)**的时间复</description>
    </item>
    
    <item>
      <title>24.两两交换链表中的节点</title>
      <link>https://zhxiongfei.github.io/post/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 23 Jun 2020 21:40:25 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>24. 两两交换链表中的节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值</description>
    </item>
    
    <item>
      <title>278.第一个错误版本</title>
      <link>https://zhxiongfei.github.io/post/278.%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC/</link>
      <pubDate>Tue, 23 Jun 2020 10:10:30 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/278.%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC/</guid>
      <description>278.第一个错误版本 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前</description>
    </item>
    
    <item>
      <title>团灭旋转问题</title>
      <link>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E6%97%8B%E8%BD%AC%E7%B3%BB%E5%88%97/</link>
      <pubDate>Mon, 22 Jun 2020 10:55:43 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E6%97%8B%E8%BD%AC%E7%B3%BB%E5%88%97/</guid>
      <description>旋转问题 leetcode上有一系列的，旋转相关的题目，旋转字符串，旋转链表，旋转数组等等. 这篇文章中，我们来逐个解决这些问题。 其实考察的知识</description>
    </item>
    
    <item>
      <title>团灭滑动窗口问题</title>
      <link>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 18 Jun 2020 14:56:29 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/</guid>
      <description>题外话 今天开始刷 LeetCode 探索频道, 字节跳动的题目，一道字符串相关的经典题目，无重复最长子串. 明明记得做过, 然而写完暴力法，在尝试进行时间复杂度优化</description>
    </item>
    
    <item>
      <title>1014.最佳观光组合</title>
      <link>https://zhxiongfei.github.io/post/1014.%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/</link>
      <pubDate>Thu, 18 Jun 2020 00:13:21 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/1014.%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/</guid>
      <description>1014. 最佳观光组合 给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i &amp;lt; j）组成的观光组合的得</description>
    </item>
    
    <item>
      <title>团灭二叉树路径总和问题</title>
      <link>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 17 Jun 2020 16:12:46 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E9%97%AE%E9%A2%98/</guid>
      <description>二叉树的路径总和问题 LeetCode上有一系列的 二叉树路径总和 的问题, 如图 这篇文章中我们按照 I, II, III的顺序依次解决此类题目 112. 路径总和 给定一</description>
    </item>
    
    <item>
      <title>剑指offer.树的子结构</title>
      <link>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 17 Jun 2020 14:59:43 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>面试题26. 树的子结构 姐妹篇 04.10检查子树 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构</description>
    </item>
    
    <item>
      <title>剑指offer36.二叉搜索树与双向链表</title>
      <link>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer36.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 16 Jun 2020 22:25:37 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer36.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>面试题36. 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指</description>
    </item>
    
    <item>
      <title>八皇后与回溯算法</title>
      <link>https://zhxiongfei.github.io/post/%E5%85%AB%E7%9A%87%E5%90%8E%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 15 Jun 2020 21:10:05 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%85%AB%E7%9A%87%E5%90%8E%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
      <description>八皇后问题 首先我们了解一下著名的八皇后问题 八皇后问题，一个古老而著名的问题，是回溯算法的典型案例。该问题由国际西洋棋棋手马克斯·贝瑟尔于 1848 年</description>
    </item>
    
    <item>
      <title>数位dp.2的出现次数</title>
      <link>https://zhxiongfei.github.io/post/%E6%95%B0%E4%BD%8Ddp.2%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Sun, 14 Jun 2020 14:08:38 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E6%95%B0%E4%BD%8Ddp.2%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</guid>
      <description>面试题 17.06. 2出现的次数 编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。 示例: 输入: 25 输出: 9 解释: (2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次</description>
    </item>
    
    <item>
      <title>Git操作指南转载</title>
      <link>https://zhxiongfei.github.io/post/git%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97%E8%BD%AC%E8%BD%BD/</link>
      <pubDate>Fri, 12 Jun 2020 10:49:43 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/git%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97%E8%BD%AC%E8%BD%BD/</guid>
      <description>git - 简易指南 转载自原文地址助你开始使用 git 的简易指南，木有高深内容，;)。 Tweet 作者：罗杰·杜德勒 感谢：@tfnico, @fhd and Namics 其他语言 english, deutsch, espa</description>
    </item>
    
    <item>
      <title>503.下一个更大元素II</title>
      <link>https://zhxiongfei.github.io/post/503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii/</link>
      <pubDate>Thu, 11 Jun 2020 17:47:03 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii/</guid>
      <description>503. 下一个更大元素 II 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按</description>
    </item>
    
    <item>
      <title>团灭单调栈Next Great Element问题</title>
      <link>https://zhxiongfei.github.io/post/%E5%8D%95%E8%B0%83%E6%A0%88%E8%A7%A3%E5%86%B3nextgreatelement%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 11 Jun 2020 17:03:20 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%8D%95%E8%B0%83%E6%A0%88%E8%A7%A3%E5%86%B3nextgreatelement%E9%97%AE%E9%A2%98/</guid>
      <description>单调栈 栈(stack) 是一种特殊的线性表，只能在一端进行操作。 往栈中添加元素，叫做push，入栈 从栈中移除元素，叫做pop，出栈 后进先出的原</description>
    </item>
    
    <item>
      <title>496.下一个更大元素I</title>
      <link>https://zhxiongfei.github.io/post/496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0i/</link>
      <pubDate>Thu, 11 Jun 2020 17:00:52 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0i/</guid>
      <description>496. 下一个更大元素 I 给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。 nums1 中数字 x 的下一个更</description>
    </item>
    
    <item>
      <title>739.每日温度</title>
      <link>https://zhxiongfei.github.io/post/739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</link>
      <pubDate>Thu, 11 Jun 2020 13:14:14 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</guid>
      <description>739. 每日温度 根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0</description>
    </item>
    
    <item>
      <title>递归-汉诺塔问题</title>
      <link>https://zhxiongfei.github.io/post/%E9%80%92%E5%BD%92-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 10 Jun 2020 16:40:17 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E9%80%92%E5%BD%92-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</guid>
      <description>面试题 08.06. 汉诺塔问题 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第</description>
    </item>
    
    <item>
      <title>简单了解递归</title>
      <link>https://zhxiongfei.github.io/post/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E9%80%92%E5%BD%92/</link>
      <pubDate>Wed, 10 Jun 2020 12:26:51 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E9%80%92%E5%BD%92/</guid>
      <description>递归(Recursion) 定义： 函数自身直接或间接调用自身，是一种常用的变成技巧。 生活中的递归现象： 从前有座山，山里有座庙，庙里有个老和尚，</description>
    </item>
    
    <item>
      <title>面试题46.把数字翻译成字符串</title>
      <link>https://zhxiongfei.github.io/post/%E9%9D%A2%E8%AF%95%E9%A2%9846.%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 09 Jun 2020 23:01:15 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E9%9D%A2%E8%AF%95%E9%A2%9846.%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>面试题46.把数字翻译成字符串 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，</description>
    </item>
    
    <item>
      <title>Charles为什么能抓https?</title>
      <link>https://zhxiongfei.github.io/post/charles%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8A%93https/</link>
      <pubDate>Tue, 09 Jun 2020 10:36:04 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/charles%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8A%93https/</guid>
      <description>经历 曾经去某公司ms, 公司名称就不透露了， 面试官问到，Charles为什么能抓https? 当时没回答上来。一年半以后，终于把有关https 加</description>
    </item>
    
    <item>
      <title>Https为什么是安全的？</title>
      <link>https://zhxiongfei.github.io/post/https%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84/</link>
      <pubDate>Mon, 08 Jun 2020 15:50:47 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/https%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84/</guid>
      <description>姐妹篇 简单了解对称和非对称加密 单向散列函数 数字签名 CA数字证书 HTTPS HTTP 有以下安全性问题： 使用明文进行通信， 内容可能会被窃听 不验证通信方的身份，通</description>
    </item>
    
    <item>
      <title>简单了解并查集</title>
      <link>https://zhxiongfei.github.io/post/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Mon, 08 Jun 2020 13:55:31 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>需求分析 假设有 N 个村庄, 有些村庄之间有连接的路，有些村庄之间没有连接的路 设计一个数据结构，能够快速执行两个操作 查询两个村庄之间是否有连接的路</description>
    </item>
    
    <item>
      <title>剑指offe21.调整数组顺序使奇数位于偶数前面</title>
      <link>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offe21.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</link>
      <pubDate>Sat, 06 Jun 2020 21:31:33 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offe21.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</guid>
      <description>面试题21. 调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位</description>
    </item>
    
    <item>
      <title>团灭两数之和问题</title>
      <link>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 06 Jun 2020 11:13:38 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98/</guid>
      <description>1. 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会</description>
    </item>
    
    <item>
      <title>404.左叶子和</title>
      <link>https://zhxiongfei.github.io/post/404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E5%92%8C/</link>
      <pubDate>Sat, 06 Jun 2020 01:06:51 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E5%92%8C/</guid>
      <description>404. 左叶子之和 计算给定二叉树的所有左叶子之和。 示例： ​ 3 / 9 20 / 15 7 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 来源：力扣（Lee</description>
    </item>
    
    <item>
      <title>iOS签名机制</title>
      <link>https://zhxiongfei.github.io/post/ios%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 05 Jun 2020 23:26:21 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/ios%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/</guid>
      <description>姐妹篇 简单了解对称和非对称加密 单向散列函数 数字签名 CA数字证书 iOS签名机制 iOS签名机制的作用 保证安装到用户手机上的APP都是经过Appl</description>
    </item>
    
    <item>
      <title>剑指offer53.0-n-1中缺失的数字</title>
      <link>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer53.%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 05 Jun 2020 15:45:25 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer53.%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>面试题53 - II. 0～n-1中缺失的数字 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-</description>
    </item>
    
    <item>
      <title>278.寻找重复数</title>
      <link>https://zhxiongfei.github.io/post/278.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</link>
      <pubDate>Fri, 05 Jun 2020 12:55:09 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/278.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</guid>
      <description>287. 寻找重复数 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，</description>
    </item>
    
    <item>
      <title>CA数字证书</title>
      <link>https://zhxiongfei.github.io/post/ca%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</link>
      <pubDate>Fri, 05 Jun 2020 01:51:42 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/ca%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</guid>
      <description>证书 证书，联想的是驾驶证、毕业证、英语四六级证等等，都是由权威机构认证的 密码学中的证书，全称叫公钥证书（Public-key Certific</description>
    </item>
    
    <item>
      <title>数字签名</title>
      <link>https://zhxiongfei.github.io/post/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</link>
      <pubDate>Fri, 05 Jun 2020 01:01:20 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</guid>
      <description>想象以下场景 Alice发的内容有可能是被篡改的，或者有人伪装成Alice发消息，或者就是Alice发的，但她可以否认 问题来了：Bob如何确定</description>
    </item>
    
    <item>
      <title>单向散列函数</title>
      <link>https://zhxiongfei.github.io/post/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 04 Jun 2020 23:42:03 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</guid>
      <description>单向散列函数(One-way hash function) 概念 单向散列函数，又被称为消息摘要函数（message digest function），哈希函数 输出的散列值，也被称为消</description>
    </item>
    
    <item>
      <title>简单了解对称和非对称加密</title>
      <link>https://zhxiongfei.github.io/post/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</link>
      <pubDate>Thu, 04 Jun 2020 13:46:26 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</guid>
      <description>学前须知 学习对称/非对称加密的主要目的是，学习iOS的签名机制. 我们简单的掌握一下，对称/非对称加密，常用算法，以及其原理，有助于我们理解签</description>
    </item>
    
    <item>
      <title>剑指offer.52.两个链表的第一个公共节点</title>
      <link>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.52.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 02 Jun 2020 21:54:04 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.52.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description>面试题52. 两个链表的第一个公共节点 输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：interse</description>
    </item>
    
    <item>
      <title>剑指offer.60.n个骰子的点数</title>
      <link>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.60.n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</link>
      <pubDate>Tue, 02 Jun 2020 21:52:35 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.60.n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</guid>
      <description>面试题60. n个骰子的点数 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数</description>
    </item>
    
    <item>
      <title>剑指offer.68.二叉树的最近公共祖先</title>
      <link>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.68.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Tue, 02 Jun 2020 21:51:04 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%89%91%E6%8C%87offer.68.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>面试题68 - I. 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树</description>
    </item>
    
    <item>
      <title>415.字符串相加</title>
      <link>https://zhxiongfei.github.io/post/415.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Mon, 01 Jun 2020 22:23:54 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/415.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</guid>
      <description>415. 字符串相加 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100. num1 和num2 都只包含数字 0-9. num1 和num2 都</description>
    </item>
    
    <item>
      <title>儿童节快乐-来自leetcode友好的祝福</title>
      <link>https://zhxiongfei.github.io/post/%E5%84%BF%E7%AB%A5%E8%8A%82%E5%BF%AB%E4%B9%90-%E6%9D%A5%E8%87%AAleetcode%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%A5%9D%E7%A6%8F/</link>
      <pubDate>Mon, 01 Jun 2020 17:47:30 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%84%BF%E7%AB%A5%E8%8A%82%E5%BF%AB%E4%B9%90-%E6%9D%A5%E8%87%AAleetcode%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%A5%9D%E7%A6%8F/</guid>
      <description>6.1儿童节 今天是6.1儿童节, 今日份 leetcode 每日一题非常友好 , 可以说是儿童节福利题. 1431. 拥有最多糖果的孩子 给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第</description>
    </item>
    
    <item>
      <title>归并排序</title>
      <link>https://zhxiongfei.github.io/post/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 31 May 2020 17:42:58 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>归并排序(merge sort) 于1945年，由冯诺伊曼提出首次提出 执行流程 不断地将数组平均分割成两个子序列, 直到不能再分割为止(只有一个元素) 不断地</description>
    </item>
    
    <item>
      <title>团灭丑数问题</title>
      <link>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E4%B8%91%E6%95%B0%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 30 May 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%9B%A2%E7%81%AD%E4%B8%91%E6%95%B0%E9%97%AE%E9%A2%98/</guid>
      <description>什么是丑数？ 先看一下百度百科的解释: 说法一（ugly number）：把只包含质因子2，3和5的数称作丑数（Ugly Number）。例如6、8</description>
    </item>
    
    <item>
      <title>二叉堆</title>
      <link>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E5%A0%86/</link>
      <pubDate>Fri, 29 May 2020 17:27:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E5%A0%86/</guid>
      <description>二叉堆 概念 堆是一个可以被看作近似完全二叉树的数组。树上的每一个节点对应数组的一个元素。出了最底层外，该树是完全充满的，而且是从左到右填充哦。</description>
    </item>
    
    <item>
      <title>01.08零矩阵</title>
      <link>https://zhxiongfei.github.io/post/01.08%E9%9B%B6%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Thu, 28 May 2020 22:55:05 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.08%E9%9B%B6%E7%9F%A9%E9%98%B5/</guid>
      <description>面试题 01.08. 零矩阵 编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。 示例 1： 输入： [ [1,1,1], [1,0,1], [1,1,1] ] 输出： [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2： 输入： [ [0,1,2,0], [3,4,5,2],</description>
    </item>
    
    <item>
      <title>01.07旋转矩阵</title>
      <link>https://zhxiongfei.github.io/post/01.07%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Thu, 28 May 2020 22:52:33 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.07%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</guid>
      <description>面试题 01.07. 旋转矩阵 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。 不占用额外内存空间能否做到？ 示</description>
    </item>
    
    <item>
      <title>01.06字符串压缩</title>
      <link>https://zhxiongfei.github.io/post/01.06%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</link>
      <pubDate>Thu, 28 May 2020 22:37:48 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.06%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</guid>
      <description>面试题 01.06. 字符串压缩 字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b</description>
    </item>
    
    <item>
      <title>01.05一次编辑</title>
      <link>https://zhxiongfei.github.io/post/01.05%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/</link>
      <pubDate>Thu, 28 May 2020 22:32:11 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.05%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/</guid>
      <description>面试题 01.05. 一次编辑 字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零</description>
    </item>
    
    <item>
      <title>01.04.回文排列</title>
      <link>https://zhxiongfei.github.io/post/01.04%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97/</link>
      <pubDate>Thu, 28 May 2020 22:27:06 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.04%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97/</guid>
      <description>面试题 01.04. 回文排列 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。 回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排</description>
    </item>
    
    <item>
      <title>01.03URL化</title>
      <link>https://zhxiongfei.github.io/post/01.03url%E5%8C%96/</link>
      <pubDate>Thu, 28 May 2020 22:22:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.03url%E5%8C%96/</guid>
      <description>面试题 01.03. URL化 URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”</description>
    </item>
    
    <item>
      <title>01.02判断是否互为字符重排</title>
      <link>https://zhxiongfei.github.io/post/01.02%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/</link>
      <pubDate>Thu, 28 May 2020 22:18:56 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.02%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/</guid>
      <description>面试题 01.02. 判定是否互为字符重排 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。 示例 1： 输入:</description>
    </item>
    
    <item>
      <title>01.01判断字符是否唯一</title>
      <link>https://zhxiongfei.github.io/post/01.01%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</link>
      <pubDate>Thu, 28 May 2020 22:15:10 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.01%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</guid>
      <description>面试题 01.01. 判定字符是否唯一 实现一个算法，确定一个字符串 s 的所有字符是否全都不同。 示例 1： 输入: s = &amp;ldquo;leetcode&amp;rdquo; 输出: false 示例 2： 输入: s = &amp;ldquo;abc&amp;rdquo; 输出: true 限制：</description>
    </item>
    
    <item>
      <title>1248.统计优美子数组</title>
      <link>https://zhxiongfei.github.io/post/1248.%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 27 May 2020 17:09:19 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/1248.%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>1248. 统计「优美子数组」 此题同 560, 974解题思路一致，复习时，可以一块看。 标签前序和。一并看懂前序和的问题。 给你一个整数数组 nums 和一个整数 k。 如果某</description>
    </item>
    
    <item>
      <title>560.和为K的子数组</title>
      <link>https://zhxiongfei.github.io/post/560.%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 27 May 2020 14:12:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/560.%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>560. 和为K的子数组 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1]</description>
    </item>
    
    <item>
      <title>974.和可被K整除的子数组</title>
      <link>https://zhxiongfei.github.io/post/974.%E5%92%8C%E5%8F%AF%E8%A2%ABk%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 27 May 2020 14:12:21 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/974.%E5%92%8C%E5%8F%AF%E8%A2%ABk%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>974. 和可被 K 整除的子数组 给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 示例： 输入：A = [4,5,0,-2,-3,1], K = 5 输出：7 解释： 有 7</description>
    </item>
    
    <item>
      <title>86.分隔链表</title>
      <link>https://zhxiongfei.github.io/post/86.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 26 May 2020 17:09:30 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/86.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</guid>
      <description>86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对</description>
    </item>
    
    <item>
      <title>一个iOS小需求中对算法的优化</title>
      <link>https://zhxiongfei.github.io/post/%E4%B8%80%E4%B8%AAios%E5%B0%8F%E9%9C%80%E6%B1%82%E4%B8%AD%E5%AF%B9%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 26 May 2020 10:49:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%B8%80%E4%B8%AAios%E5%B0%8F%E9%9C%80%E6%B1%82%E4%B8%AD%E5%AF%B9%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96/</guid>
      <description>需求 最近接到一个小需求, 在一个feed流里, 展示商品列表，商品列表中数据都是一样的，只是展示上有主推的商品，需要大图展示, 其余商品小图展示。</description>
    </item>
    
    <item>
      <title>169.多数元素与摩尔投票算法</title>
      <link>https://zhxiongfei.github.io/post/169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%E4%B8%8E%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 25 May 2020 18:01:27 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%E4%B8%8E%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/</guid>
      <description>要了解，摩尔投票，首先看一道题目 169. 多数元素 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假</description>
    </item>
    
    <item>
      <title>146.LRU缓存机制</title>
      <link>https://zhxiongfei.github.io/post/146.lru%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 25 May 2020 16:01:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/146.lru%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
      <description>146. LRU缓存机制 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如</description>
    </item>
    
    <item>
      <title>01.09字符串轮转</title>
      <link>https://zhxiongfei.github.io/post/01.09%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/01.09%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC/</guid>
      <description>面试题 01.09. 字符串轮转 字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottle</description>
    </item>
    
    <item>
      <title>02.01移除重复节点</title>
      <link>https://zhxiongfei.github.io/post/02.01%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.01%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</guid>
      <description>面试题 02.01. 移除重复节点 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。 示例1: 输入：[1, 2, 3, 3, 2, 1] 输出：[1, 2, 3] 示例2: 输入：</description>
    </item>
    
    <item>
      <title>02.02链表的倒数第二个节点</title>
      <link>https://zhxiongfei.github.io/post/02.02%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.02%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>面试题 02.02. 返回倒数第 k 个节点 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 注意：本题相对原题稍作改动 示例： 输入： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 和 k = 2 输出：</description>
    </item>
    
    <item>
      <title>02.03删除中间节点</title>
      <link>https://zhxiongfei.github.io/post/02.03%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.03%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</guid>
      <description>面试题 02.03. 删除中间节点 实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。 示例： 输入</description>
    </item>
    
    <item>
      <title>02.04分割链表</title>
      <link>https://zhxiongfei.github.io/post/02.04%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.04%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</guid>
      <description>面试题 02.04. 分割链表 编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(</description>
    </item>
    
    <item>
      <title>02.05链表求和</title>
      <link>https://zhxiongfei.github.io/post/02.05%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.05%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/</guid>
      <description>面试题 02.05. 链表求和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 给定两个用链表表示的整数，每个节点包含一个数位。 这些数位是反向存放的，也就是个位</description>
    </item>
    
    <item>
      <title>02.06回文链表</title>
      <link>https://zhxiongfei.github.io/post/02.06%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.06%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>面试题 02.06. 回文链表 编写一个函数，检查输入的链表是否是回文的。 示例 1： 输入： 1-&amp;gt;2 输出： false 示例 2： 输入： 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出： true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间</description>
    </item>
    
    <item>
      <title>02.08环路检测</title>
      <link>https://zhxiongfei.github.io/post/02.08%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/02.08%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/</guid>
      <description>面试题 02.08. 环路检测 给定一个有环链表，实现一个算法返回环路的开头节点。 有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则</description>
    </item>
    
    <item>
      <title>03.02栈的最小值</title>
      <link>https://zhxiongfei.github.io/post/03.02%E6%A0%88%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/03.02%E6%A0%88%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</guid>
      <description>面试题 03.02. 栈的最小值 请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop</description>
    </item>
    
    <item>
      <title>03.04化栈为队</title>
      <link>https://zhxiongfei.github.io/post/03.04%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/03.04%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F/</guid>
      <description>面试题 03.04. 化栈为队 实现一个MyQueue类，该类用两个栈来实现一个队列。 示例： MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false 说明： 你只能使用标准</description>
    </item>
    
    <item>
      <title>04.02最小高度树</title>
      <link>https://zhxiongfei.github.io/post/04.02%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/04.02%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</guid>
      <description>面试题 04.02. 最小高度树 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能</description>
    </item>
    
    <item>
      <title>04.03特定深度节点链表</title>
      <link>https://zhxiongfei.github.io/post/04.03%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/04.03%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/</guid>
      <description>面试题 04.03. 特定深度节点链表 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回</description>
    </item>
    
    <item>
      <title>04.05合法二叉搜索树</title>
      <link>https://zhxiongfei.github.io/post/04.05%E5%90%88%E6%B3%95%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/04.05%E5%90%88%E6%B3%95%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>面试题 04.05. 合法二叉搜索树 实现一个函数，检查一棵二叉树是否为二叉搜索树。 示例 1: 输入: 2 / 1 3 输出: true 示例 2: 输入: 5 / 1 4 / 3 6 输出: false 解释: 输入</description>
    </item>
    
    <item>
      <title>04.06后继者</title>
      <link>https://zhxiongfei.github.io/post/04.06%E5%90%8E%E7%BB%A7%E8%80%85/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/04.06%E5%90%8E%E7%BB%A7%E8%80%85/</guid>
      <description>面试题 04.06. 后继者 设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。 如果指定节点没有对应的“下一个”节点，则返回null。</description>
    </item>
    
    <item>
      <title>04.08首个公共祖先</title>
      <link>https://zhxiongfei.github.io/post/04.08%E9%A6%96%E4%B8%AA%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/04.08%E9%A6%96%E4%B8%AA%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>面试题 04.08. 首个共同祖先 设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉</description>
    </item>
    
    <item>
      <title>04.10检查子树</title>
      <link>https://zhxiongfei.github.io/post/04.10%E6%A3%80%E6%9F%A5%E5%AD%90%E6%A0%91/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/04.10%E6%A3%80%E6%9F%A5%E5%AD%90%E6%A0%91/</guid>
      <description>面试题 04.10. 检查子树 检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。 如果 T1 有这么一</description>
    </item>
    
    <item>
      <title>08.01三步问题</title>
      <link>https://zhxiongfei.github.io/post/08.01%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/08.01%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98/</guid>
      <description>面试题 08.01. 三步问题 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结</description>
    </item>
    
    <item>
      <title>08.03魔术索引</title>
      <link>https://zhxiongfei.github.io/post/08.03%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/08.03%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/</guid>
      <description>面试题 08.03. 魔术索引 魔术索引。 在数组A[0&amp;hellip;n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法</description>
    </item>
    
    <item>
      <title>10.01合并排序的数组</title>
      <link>https://zhxiongfei.github.io/post/10.01%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/10.01%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/</guid>
      <description>面试题 10.01. 合并排序的数组 给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。 初始化 A 和 B 的元素数</description>
    </item>
    
    <item>
      <title>110.平衡二叉树</title>
      <link>https://zhxiongfei.github.io/post/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值</description>
    </item>
    
    <item>
      <title>16.17连续序列</title>
      <link>https://zhxiongfei.github.io/post/16.17%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/16.17%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</guid>
      <description>面试题 16.17. 连续数列 给定一个整数数组，找出总和最大的连续数列，并返回总和。 示例： 输入： [-2,1,-3,4,-1,2,1,-5,4] 输出： 6 解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶： 如果你已</description>
    </item>
    
    <item>
      <title>17.16按摩师</title>
      <link>https://zhxiongfei.github.io/post/17.16%E6%8C%89%E6%91%A9%E5%B8%88/</link>
      <pubDate>Tue, 12 May 2020 22:31:36 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/17.16%E6%8C%89%E6%91%A9%E5%B8%88/</guid>
      <description>面试题 17.16. 按摩师 一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约</description>
    </item>
    
    <item>
      <title>AVL树</title>
      <link>https://zhxiongfei.github.io/post/avl%E6%A0%91/</link>
      <pubDate>Mon, 11 May 2020 21:04:44 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/avl%E6%A0%91/</guid>
      <description>AVL树 平衡因子(Balance Factor): 某节点左右子树的高度差 AVL树的特点 每个节点的平衡因子只可能是1, 0, -1(绝对值 &amp;lt;= 1, 如果超过1，称之为 &amp;l</description>
    </item>
    
    <item>
      <title>平衡二叉搜索树</title>
      <link>https://zhxiongfei.github.io/post/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Mon, 11 May 2020 21:03:47 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>平衡二叉搜索树 (BBST) 二叉搜索树(BST)的缺陷？ 二叉搜索树，在某种情况下会导致极度的不平衡，导致时间复杂度剧增。 如图，如果按照 7 4 9 2 5 8 11 的顺</description>
    </item>
    
    <item>
      <title>121买卖股票的最佳时机</title>
      <link>https://zhxiongfei.github.io/post/121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Sat, 09 May 2020 21:40:52 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</guid>
      <description>121. 买卖股票的最佳时机 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一</description>
    </item>
    
    <item>
      <title>938. 二叉搜索树的范围和</title>
      <link>https://zhxiongfei.github.io/post/938.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</link>
      <pubDate>Sat, 09 May 2020 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/938.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</guid>
      <description>938. 二叉搜索树的范围和 题解： 二叉树中序遍历， 递加在 [L , R] 范围的元素即可。 思路一： 递归 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 int sum = 0; public int rangeSumBST(TreeNode root, int L, int R){</description>
    </item>
    
    <item>
      <title>二叉搜索树</title>
      <link>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 09 May 2020 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>思考？ 在 n 个动态的整数中搜索某个整数？ (查看其是否存在) 假设用动态数组存放元素，从第0个位置开始遍历搜索，平均时间复杂度 O(N) 如果维护一个有序的</description>
    </item>
    
    <item>
      <title>iOS组件化初试之创建私有库</title>
      <link>https://zhxiongfei.github.io/post/ios-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%88%9D%E8%AF%95%E4%B9%8B%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/</link>
      <pubDate>Thu, 07 May 2020 20:45:03 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/ios-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%88%9D%E8%AF%95%E4%B9%8B%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/</guid>
      <description>iOS组件化初试之创建私有库 iOS组件的实现基本是基于cocoapods，如何利用cocoapod创建我们自己的私有库，是实现组件话的第一步</description>
    </item>
    
    <item>
      <title>803计算机学科基础综合</title>
      <link>https://zhxiongfei.github.io/post/803%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%A7%91%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88/</link>
      <pubDate>Thu, 30 Apr 2020 18:09:56 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/803%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%A7%91%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88/</guid>
      <description>一、 考查目标 计算机学科基础综合考试涵盖数据结构、计算机组成原理、操作系统和计算机网络等学科专业基础课程。要求考生比较系统地掌握上述专业基础课</description>
    </item>
    
    <item>
      <title>愿北邮成为我邮</title>
      <link>https://zhxiongfei.github.io/privates/%E6%84%BF%E5%8C%97%E9%82%AE%E6%88%90%E4%B8%BA%E6%88%91%E9%82%AE/</link>
      <pubDate>Thu, 30 Apr 2020 17:57:19 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/privates/%E6%84%BF%E5%8C%97%E9%82%AE%E6%88%90%E4%B8%BA%E6%88%91%E9%82%AE/</guid>
      <description>愿北邮成为我邮 琢磨了好几年的考研，因为张清妍的到来，显得更加紧迫了，以后时间越来越少，精力也逐渐不如以前。遂决定，不再拖，今年考研！ 仅以此文</description>
    </item>
    
    <item>
      <title>120三角形最小路径和DP</title>
      <link>https://zhxiongfei.github.io/post/120%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8Cdp/</link>
      <pubDate>Tue, 28 Apr 2020 14:27:19 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/120%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8Cdp/</guid>
      <description>120. 三角形最小路径和 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最</description>
    </item>
    
    <item>
      <title>300.最长上升子序列DP</title>
      <link>https://zhxiongfei.github.io/post/300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97dp/</link>
      <pubDate>Tue, 28 Apr 2020 11:25:21 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97dp/</guid>
      <description>300. 最长上升子序列 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，</description>
    </item>
    
    <item>
      <title>213.打家劫舍DPII</title>
      <link>https://zhxiongfei.github.io/post/213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Ddpii/</link>
      <pubDate>Mon, 27 Apr 2020 22:08:29 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Ddpii/</guid>
      <description>213. 打家劫舍 II 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋</description>
    </item>
    
    <item>
      <title>198.打家劫舍DP</title>
      <link>https://zhxiongfei.github.io/post/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Ddp/</link>
      <pubDate>Mon, 27 Apr 2020 21:06:09 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Ddp/</guid>
      <description>198. 打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如</description>
    </item>
    
    <item>
      <title>322.零钱找零DP</title>
      <link>https://zhxiongfei.github.io/post/322.%E9%9B%B6%E9%92%B1%E6%89%BE%E9%9B%B6dp/</link>
      <pubDate>Mon, 27 Apr 2020 17:40:44 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/322.%E9%9B%B6%E9%92%B1%E6%89%BE%E9%9B%B6dp/</guid>
      <description>零钱兑换 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总</description>
    </item>
    
    <item>
      <title>一文了解动态规划(Dynamic Programming)</title>
      <link>https://zhxiongfei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 27 Apr 2020 10:20:11 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</guid>
      <description>动态规划(Dynamic Programming) 简称 DP , 是求解最优化问题的一种常用策略。 来自维基百科的解释： Dynamic Programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once,and</description>
    </item>
    
    <item>
      <title>Hello,张清妍</title>
      <link>https://zhxiongfei.github.io/post/hello%E5%BC%A0%E6%B8%85%E5%A6%8D/</link>
      <pubDate>Sun, 26 Apr 2020 16:15:11 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/hello%E5%BC%A0%E6%B8%85%E5%A6%8D/</guid>
      <description>Hello, 张清妍 地点：北京天坛医院 2020年4月16日 医生检查我们嘟嘟生长受限，决定提前生产，早上vv做了otc检查，用来判断是否符合顺产的条件，o</description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>一 树形结构： 数据结构分为线性结构和树形结构，如下图： 线性结构： 树形结构： 生活中的树形结构 二 树(Tree)的基本概念 节点，父节点，子节点，跟节</description>
    </item>
    
    <item>
      <title>冒泡排序(BubbleSort)</title>
      <link>https://zhxiongfei.github.io/post/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>冒泡排序(BubbleSort) 执行流程 依次比较两个相邻元素如果前者比后者大，交换两者 一轮比较完毕，则最后一个元素为最大者 再进行第二轮比较，</description>
    </item>
    
    <item>
      <title>堆排序(Heap Sort)</title>
      <link>https://zhxiongfei.github.io/post/%E5%A0%86%E6%8E%92%E5%BA%8Fheap-sort/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%A0%86%E6%8E%92%E5%BA%8Fheap-sort/</guid>
      <description>堆排序(Heap Sort) 堆排序可以认为是选择排序的一种优化。 选择排序每一轮都在选择最大值 而选择最大值，最优的数据结构是堆 故用堆排序 优化 选择排序 执行</description>
    </item>
    
    <item>
      <title>快速排序(Quick Sort)</title>
      <link>https://zhxiongfei.github.io/post/%E5%BF%AB%E6%8E%92/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%BF%AB%E6%8E%92/</guid>
      <description>快速排序(Quick Sort) 快速排序(Quick Sort) 1960年由 查尔斯.安东尼.理查德.霍尔提出。 执行流程 随机选择一个为数列的轴点元素 遍历数组，把小</description>
    </item>
    
    <item>
      <title>插入排序(Insertion Sort)</title>
      <link>https://zhxiongfei.github.io/post/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Finsertion-sort/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Finsertion-sort/</guid>
      <description>插入排序(Insertion Sort) 执行流程 从第一位开始, 依次与之前元素比较 当比之前元素小时, 交换 挨个交换直到 末尾元素 最差时间复杂度 : O(N ^ 2) 平均时</description>
    </item>
    
    <item>
      <title>选择排序(Selection Sort)</title>
      <link>https://zhxiongfei.github.io/post/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 26 Apr 2020 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
      <description>选择排序(Selection Sort) 执行流程 找出数组中最大的那个元素，和数组末尾元素进行叫魂 执行完一轮后，数组末尾的元素就是最大元素 依次找出剩余元</description>
    </item>
    
    <item>
      <title>队列</title>
      <link>https://zhxiongfei.github.io/post/%E9%98%9F%E5%88%97/</link>
      <pubDate>Sat, 25 Apr 2020 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E9%98%9F%E5%88%97/</guid>
      <description>队列 一，定义 队列是一种特殊的线性表，只能在头尾两端进行操作 队尾(rear) : 只能从队尾添加元素，一般叫做enQueue,入队 对头(front</description>
    </item>
    
    <item>
      <title>集合</title>
      <link>https://zhxiongfei.github.io/post/%E9%9B%86%E5%90%88/</link>
      <pubDate>Wed, 15 Apr 2020 22:20:03 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E9%9B%86%E5%90%88/</guid>
      <description>集合（Set） 集合的定义： 由一个或者多个确定的元素所构成的整体。 特点： 1，不存在重复元素 2，一般用于去重（比如一本书中统计词汇，统计访问网站</description>
    </item>
    
    <item>
      <title>83. 删除排序链表的重复节点</title>
      <link>https://zhxiongfei.github.io/post/83.-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 14 Apr 2020 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/83.-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</guid>
      <description>83. 删除排序链表中的重复元素 题解： 当前节点的值与当前节点next的值相同时，当前节点的.next指向其next.next。 不相同时直接进入下次</description>
    </item>
    
    <item>
      <title>876. 链表的中间节点</title>
      <link>https://zhxiongfei.github.io/post/876.%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 14 Apr 2020 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/876.%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</guid>
      <description>876. 链表的中间结点 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,</description>
    </item>
    
    <item>
      <title>数据结构学习 --&gt; 算法评判标准</title>
      <link>https://zhxiongfei.github.io/post/%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Wed, 08 Apr 2020 17:33:35 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description>首先看一到leetcode题目:斐波那契数列。 509. 斐波那契数 斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每</description>
    </item>
    
    <item>
      <title>面试题55-1.二叉树的深度</title>
      <link>https://zhxiongfei.github.io/post/55-1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 25 Feb 2020 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/55-1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>面试题55 - I. 二叉树的深度 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长</description>
    </item>
    
    <item>
      <title>35. 搜索插入位置</title>
      <link>https://zhxiongfei.github.io/post/35.-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Mon, 10 Feb 2020 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/35.-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</guid>
      <description>35. 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以</description>
    </item>
    
    <item>
      <title>662.二叉树最大宽度</title>
      <link>https://zhxiongfei.github.io/post/662.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/</link>
      <pubDate>Sat, 25 Jan 2020 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/662.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/</guid>
      <description>662. 二叉树最大宽度 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）</description>
    </item>
    
    <item>
      <title>26.删除排序数组中的重复项</title>
      <link>https://zhxiongfei.github.io/post/26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Sun, 19 Jan 2020 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-</description>
    </item>
    
    <item>
      <title>150. 逆波兰表达式求值</title>
      <link>https://zhxiongfei.github.io/post/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</link>
      <pubDate>Wed, 11 Dec 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</guid>
      <description>150. 逆波兰表达式求值 根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除</description>
    </item>
    
    <item>
      <title>152. 乘积最大子数组</title>
      <link>https://zhxiongfei.github.io/post/152.-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 09 Dec 2019 21:40:02 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/152.-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>152. 乘积最大子数组 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。 示例 1: 输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有</description>
    </item>
    
    <item>
      <title>145.二叉树的后序遍历</title>
      <link>https://zhxiongfei.github.io/post/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 25 Nov 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>145. 二叉树的后序遍历 给定一个二叉树，返回它的 后序 遍历。 示例: 输入: [1,null,2,3] 1 2 / 3 输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 来源：力扣</description>
    </item>
    
    <item>
      <title>144.二叉树的前序遍历</title>
      <link>https://zhxiongfei.github.io/post/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 21 Nov 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树的遍历 有两种遍历树的策略： 深度优先搜索(DFS) 在这个策略中，我们采用深度作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根</description>
    </item>
    
    <item>
      <title>235. 二叉搜索树的最近公共祖先</title>
      <link>https://zhxiongfei.github.io/post/235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Tue, 19 Nov 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>235. 二叉搜索树的最近公共祖先 题解： 思路一： 我们使用 HashMap 来存储，子节点的值 -&amp;gt; 父节点。 dfs二叉树，构建map，保存每个节点对应的父节点 根据map，</description>
    </item>
    
    <item>
      <title>450.删除二叉搜索树中的节点</title>
      <link>https://zhxiongfei.github.io/post/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 09 Nov 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>练习题： 450. 删除二叉搜索树中的节点 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回</description>
    </item>
    
    <item>
      <title>98.验证二叉搜索树</title>
      <link>https://zhxiongfei.github.io/post/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Wed, 06 Nov 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>98. 验证二叉搜索树 题解： 迭代 和 递归两种方法思路一样， 都是利用二叉树的中序遍历 二叉搜索树的中序遍历结果，是严格升序的， 所以我们中序遍历二叉树 记录</description>
    </item>
    
    <item>
      <title>142.环形链表II</title>
      <link>https://zhxiongfei.github.io/post/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</link>
      <pubDate>Sat, 26 Oct 2019 18:09:26 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</guid>
      <description>142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接</description>
    </item>
    
    <item>
      <title>349. 两个数组的交集</title>
      <link>https://zhxiongfei.github.io/post/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</link>
      <pubDate>Tue, 15 Oct 2019 22:20:03 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</guid>
      <description>349. 两个数组的交集 给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [9,4] 说明: 输出结果中</description>
    </item>
    
    <item>
      <title>20. 有效的括号</title>
      <link>https://zhxiongfei.github.io/post/20.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Thu, 10 Oct 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/20.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid>
      <description>栈 栈是一种特殊的线性表,只能在一端操作 往栈中添加元素的操作，一般叫做push，入栈 从栈中移除元素的操作，一般叫做pop，出栈（只能移除栈顶元</description>
    </item>
    
    <item>
      <title>88. 合并两个有序数组</title>
      <link>https://zhxiongfei.github.io/post/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 21 Sep 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>88. 合并两个有序数组 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你</description>
    </item>
    
    <item>
      <title>27.移除元素</title>
      <link>https://zhxiongfei.github.io/post/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</link>
      <pubDate>Tue, 03 Sep 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</guid>
      <description>27. 移除元素](https://leetcode-cn.com/problems/remove-element/) 给你一个数组 nums 和一个值 val</description>
    </item>
    
    <item>
      <title>53. 最大子序和DP</title>
      <link>https://zhxiongfei.github.io/post/53.-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8Cdp/</link>
      <pubDate>Wed, 28 Aug 2019 20:56:35 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/53.-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8Cdp/</guid>
      <description>53. 最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数</description>
    </item>
    
    <item>
      <title>234.回文链表</title>
      <link>https://zhxiongfei.github.io/post/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 26 Aug 2019 18:21:27 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>234. 回文链表 请判断一个链表是否为回文链表。 示例 1: 输入: 1-&amp;gt;2 输出: false 示例 2: 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 来源：</description>
    </item>
    
    <item>
      <title>141.环形链表</title>
      <link>https://zhxiongfei.github.io/post/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 26 Aug 2019 17:58:30 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>141. 环形链表 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -</description>
    </item>
    
    <item>
      <title>17.12.BiNode</title>
      <link>https://zhxiongfei.github.io/post/17.12.binode/</link>
      <pubDate>Sun, 25 Aug 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/17.12.binode/</guid>
      <description>面试题 17.12. BiNode 二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为</description>
    </item>
    
    <item>
      <title>94.二叉树的中序遍历</title>
      <link>https://zhxiongfei.github.io/post/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 25 Aug 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树的遍历 有两种遍历树的策略： 深度优先搜索(DFS) 在这个策略中，我们采用深度作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根</description>
    </item>
    
    <item>
      <title>19.删除链表的倒数第N个节点</title>
      <link>https://zhxiongfei.github.io/post/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 14 Aug 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>19. 删除链表的倒数第N个节点 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2. 当删除了倒数第二个节点</description>
    </item>
    
    <item>
      <title>206.反转链表</title>
      <link>https://zhxiongfei.github.io/post/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 14 Aug 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>206. 反转链表 反转一个单链表。 示例: 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 来源：力扣（LeetCode）</description>
    </item>
    
    <item>
      <title>1. 两数之和</title>
      <link>https://zhxiongfei.github.io/post/1.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Sun, 11 Aug 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/1.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>1. 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会</description>
    </item>
    
    <item>
      <title>2.两数相加</title>
      <link>https://zhxiongfei.github.io/post/2.-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Fri, 26 Jul 2019 16:34:46 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/2.-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>2. 两数相加 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我</description>
    </item>
    
    <item>
      <title>21. 合并两个有序链表</title>
      <link>https://zhxiongfei.github.io/post/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 14 Jul 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>21. 合并两个有序链表 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&amp;gt;2-&amp;</description>
    </item>
    
    <item>
      <title>11.盛最多水的容器</title>
      <link>https://zhxiongfei.github.io/post/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 11 Jul 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
      <description>11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)</description>
    </item>
    
    <item>
      <title>203.移除链表 元素</title>
      <link>https://zhxiongfei.github.io/post/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8-%E5%85%83%E7%B4%A0/</link>
      <pubDate>Fri, 21 Jun 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8-%E5%85%83%E7%B4%A0/</guid>
      <description>203. 移除链表元素 删除链表中等于给定值 *val* 的所有节点。 示例: 1 2 输入: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 题解： 如果删除的是中间节点， 此题看起来非常简单，直接拿到pr</description>
    </item>
    
    <item>
      <title>237. 删除链表中的节点</title>
      <link>https://zhxiongfei.github.io/post/237.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 11 May 2019 20:33:49 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/237.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>链表(Linked List) 动态数组有个明显的缺点，可能会造成内存空间浪费。 链表可以做到用多少就申请多少内存。 链表是一种链式存储的线性表，所有元素的</description>
    </item>
    
    <item>
      <title>108.将有序数组转换成二叉搜索树</title>
      <link>https://zhxiongfei.github.io/post/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Thu, 09 May 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>108. 将有序数组转换为二叉搜索树 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左</description>
    </item>
    
    <item>
      <title>230. 二叉搜索树中第K小的元素</title>
      <link>https://zhxiongfei.github.io/post/230.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 09 May 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/230.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>230. 二叉搜索树中第K小的元素 题解： 二叉搜索树中序遍历的结果，是升序数组， 所以先中序遍历数组，第k个元素即为第k个小的元素。 思路一： 迭代 代码如下</description>
    </item>
    
    <item>
      <title>530.二叉树的最小绝对差</title>
      <link>https://zhxiongfei.github.io/post/530.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</link>
      <pubDate>Thu, 09 May 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/530.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</guid>
      <description>530. 二叉搜索树的最小绝对差 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 题解： 二叉搜索树中序遍历的结果，是</description>
    </item>
    
    <item>
      <title>700.二叉搜索树中的搜索</title>
      <link>https://zhxiongfei.github.io/post/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Thu, 09 May 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</guid>
      <description>700. 二叉搜索树中的搜索 题解： 思路一： 迭代：题目非常简单，普通的二叉搜索树查找。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 二叉搜索树性</description>
    </item>
    
    <item>
      <title>701.二叉搜索树中的插入操作</title>
      <link>https://zhxiongfei.github.io/post/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Thu, 09 May 2019 21:35:41 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</guid>
      <description>701. 二叉搜索树中的插入操作 题解： 二叉搜索树的插入操作非常简单，当val &amp;gt; root.val时，插入root的左子树, 当val &amp;lt; root.val时</description>
    </item>
    
    <item>
      <title>226.翻转二叉树</title>
      <link>https://zhxiongfei.github.io/post/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 26 Apr 2019 10:15:13 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>226. 翻转二叉树 翻转一棵二叉树。 示例： 输入： 4 / 2 7 / \ / 1 3 6 9 输出： 4 / 7 2 / \ / 9 6 3 1 备注: 这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们</description>
    </item>
    
    <item>
      <title>102.二叉树的层序遍历</title>
      <link>https://zhxiongfei.github.io/post/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>102. 二叉树的层序遍历 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例： 二叉树：[3,9,20,nul</description>
    </item>
    
    <item>
      <title>104.二叉树的最大深度</title>
      <link>https://zhxiongfei.github.io/post/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>104. 二叉树的最大深度 题解： 思路一： 使用递归， node节点的高度等于其 max(node.left, node.right) + 1 左右孩子的高度中的较大者 + 1. 代码如下： 1 2 3 4 5 public int maxDepth(TreeNode root){ if (root == null) return</description>
    </item>
    
    <item>
      <title>105.从前序与中序遍历序列构造二叉树</title>
      <link>https://zhxiongfei.github.io/post/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>105. 从前序与中序遍历序列构造二叉树 根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍</description>
    </item>
    
    <item>
      <title>106.从中序与后序遍历构造二叉树</title>
      <link>https://zhxiongfei.github.io/post/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>106. 从中序与后序遍历序列构造二叉树 根据一棵树的中序遍历与后序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍</description>
    </item>
    
    <item>
      <title>114.二叉树展开为链表</title>
      <link>https://zhxiongfei.github.io/post/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid>
      <description>114. 二叉树展开为链表 题解： 思路一： 迭代, 可以发现展开的顺序其实就是二叉树前序遍历。 将左子树插入到右子树 将原来的右子树插入到左子树最右边节点 考虑</description>
    </item>
    
    <item>
      <title>222.完全二叉树的节点个数</title>
      <link>https://zhxiongfei.github.io/post/222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</guid>
      <description>222. 完全二叉树的节点个数 给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每</description>
    </item>
    
    <item>
      <title>225.用队列实现栈</title>
      <link>https://zhxiongfei.github.io/post/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</guid>
      <description>225. 用队列实现栈 使用队列实现栈的下列操作： push(x) &amp;ndash; 元素 x 入栈 pop() &amp;ndash; 移除栈顶元素 top() &amp;ndash; 获取栈顶元素 empty() &amp;ndash; 返回栈是否为空 注意: 你只能使用队列的基本操作&amp;nd</description>
    </item>
    
    <item>
      <title>559.N叉树的最大深度</title>
      <link>https://zhxiongfei.github.io/post/559.n%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/559.n%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>559. N叉树的最大深度 题解： 思路一： 递归，非常容易想的思路，父节点的深度，等于其子节点中最大深度再加一。 代码如下： 1 2 3 4 5 6 7 8 9 10 public int maxDepth(Node root) {</description>
    </item>
    
    <item>
      <title>589.N叉树的前序遍历</title>
      <link>https://zhxiongfei.github.io/post/589.n%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/589.n%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>589. N叉树的前序遍历 题解： 思路一： 递归 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ArrayList list = new ArrayList(); public List&amp;lt;Integer&amp;gt; preorder(Node root) { if (root == null) return list; Node node = root; list.add(node.val); for (int i = 0; i &amp;lt; root.children.size(); i++){ preorder(node.children.get(i)); } return</description>
    </item>
    
    <item>
      <title>590.N叉树的后序遍历</title>
      <link>https://zhxiongfei.github.io/post/590.n%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 25 Apr 2019 18:25:18 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/590.n%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>590. N叉树的后序遍历 给定一个 N 叉树，返回其节点值的后序遍历。 例如，给定一个 3叉树 : 返回其后序遍历: [5,6,3,2,4,1]. 说明: 递归法很简单，你可以使用迭代法完成此</description>
    </item>
    
    <item>
      <title>202.快乐数</title>
      <link>https://zhxiongfei.github.io/post/202.%E5%BF%AB%E4%B9%90%E6%95%B0/</link>
      <pubDate>Mon, 15 Apr 2019 22:20:03 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/202.%E5%BF%AB%E4%B9%90%E6%95%B0/</guid>
      <description>202. 快乐数 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个</description>
    </item>
    
    <item>
      <title>155. 最小栈</title>
      <link>https://zhxiongfei.github.io/post/155.%E6%9C%80%E5%B0%8F%E6%A0%88/</link>
      <pubDate>Thu, 11 Apr 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/155.%E6%9C%80%E5%B0%8F%E6%A0%88/</guid>
      <description>155. 最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶</description>
    </item>
    
    <item>
      <title>232. 用栈实现队列</title>
      <link>https://zhxiongfei.github.io/post/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Thu, 11 Apr 2019 11:25:40 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>232. 用栈实现队列 使用栈实现队列的下列操作： push(x) &amp;ndash; 将一个元素放入队列的尾部。 pop() &amp;ndash; 从队列首部移除元素。 peek() &amp;ndash; 返回队列首部的元素。 empty() &amp;ndash; 返回队列是否为空。</description>
    </item>
    
    <item>
      <title>字符串常用算法 --&gt; 双指针</title>
      <link>https://zhxiongfei.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Fri, 05 Apr 2019 20:52:54 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
      <description>151. 翻转字符串里的单词 题目 给定一个字符串，逐个反转字符串中的每个单词 示例 1： 1 2 输入: &amp;#34;the sky is blue&amp;#34; 输出: &amp;#34;blue is sky the&amp;#34; 说明： 无空格字符构成一个单词。 输入</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://zhxiongfei.github.io/about/</link>
      <pubDate>Sat, 29 Dec 2018 20:24:28 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/about/</guid>
      <description>iOS Developer，喜欢逆向，偶尔刷题 非科班程序员，本科生物科学，辅修英语，自知计算机基础薄弱，努力学习中。 学习常用数据结构与算法，同步L</description>
    </item>
    
    <item>
      <title>NSObject内存结构</title>
      <link>https://zhxiongfei.github.io/post/nsobject%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 25 Jun 2018 17:24:50 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/nsobject%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</guid>
      <description>一，Objective-C的本质 我们平时编写的Objective-C代码，底层实现都是C/C++代码。 所以Objective-C的面向对象，</description>
    </item>
    
    <item>
      <title>Mac通过SSH登录iOS设备</title>
      <link>https://zhxiongfei.github.io/post/mac%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5ios%E8%AE%BE%E5%A4%87/</link>
      <pubDate>Fri, 01 Jun 2018 23:21:26 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/mac%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5ios%E8%AE%BE%E5%A4%87/</guid>
      <description>本文非原创， 是在学习李明杰课程后的知识整理，方便自己复习，也给正好需要的伙伴提供方便。 基础概念 SSH 在学习Mac通过SSH登录iOS设备之前，我</description>
    </item>
    
    <item>
      <title>Mac环境下使用Hugo搭建github博客</title>
      <link>https://zhxiongfei.github.io/post/hugo/</link>
      <pubDate>Mon, 06 Mar 2017 14:04:58 +0800</pubDate>
      
      <guid>https://zhxiongfei.github.io/post/hugo/</guid>
      <description>Mac环境下使用Hugo搭建github博客 第一步：安装hugo mac环境下用homebrew工具安装hugo，一句命令即可 1 $ brew install hugo 第二步</description>
    </item>
    
  </channel>
</rss>